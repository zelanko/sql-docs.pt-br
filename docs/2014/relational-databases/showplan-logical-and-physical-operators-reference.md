---
title: Referência de operadores físicos e lógicos de plano de execução | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.suite: ''
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
caps.latest.revision: 51
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 99d305034989f0fdd2f9ca65dae9cef7d0881c2c
ms.sourcegitcommit: c18fadce27f330e1d4f36549414e5c84ba2f46c2
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/02/2018
ms.locfileid: "37160627"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referência de operadores físicos e lógicos de plano de execução
  Os operadores descrevem como o [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executa uma consulta ou uma instrução DML (Linguagem de Manipulação de Dados). O otimizador de consultas usa os operadores para criar um plano de consulta a fim de criar o resultado especificado na consulta ou para executar a operação especificada na instrução DML. O plano de consulta é uma árvore que consiste em operadores físicos. Você pode exibir o plano de consulta usando as instruções SET SHOWPLAN, as opções de plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou as classes de evento do Plano de Execução do SQL Server Profiler.  
  
 Os operadores são classificados como lógicos e físicos.  
  
 **Operadores lógicos**  
 Os operadores lógicos descrevem a operação algébrica relacional usada para processar uma instrução. Em outras palavras, operadores lógicos descrevem conceitualmente qual operação precisa ser executada.  
  
 **Operadores físicos**  
 Os operadores físicos implementam a operação descrita pelos operadores lógicos. Cada operador físico é um objeto ou uma rotina que executa uma operação. Por exemplo, alguns operadores físicos acessam colunas ou linhas de uma tabela, índice ou exibição. Outros operadores físicos executam outras operações como cálculos, agregações, verificações da integridade de dados ou junções. Os operadores físicos possuem custos associados.  
  
 Os operadores físicos iniciam, coletam dados e fecham. Especificamente, o operador físico pode responder às três chamadas de método abaixo:  
  
-   **Init()**: o método **Init()** faz com que um operador físico se inicialize e define quaisquer estruturas de dados necessárias. O operador físico pode receber muitas chamadas **Init()** ; entretanto, um operador físico costuma receber somente uma.  
  
-   **GetNext()**: o método **GetNext()** faz um operador físico obter a primeira linha de dados ou a subsequente. O operador físico pode receber zero ou muitas chamadas **GetNext()** .  
  
-   **Close()**: o método **Close()** faz um operador físico executar algumas operações de limpeza total e se desligar. Um operador físico só recebe uma chamada **Close()** .  
  
 O método **GetNext()** retorna uma linha de dados e o número de vezes em que é chamado aparece como **ActualRows** na saída do Plano de Execução que é produzida usando as opções SET STATISTICS PROFILE ON ou SET STATISTICS XML ON. Para obter mais informações sobre essas opções SET, veja [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) e [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Os contadores **ActualRebinds** e **ActualRewinds** exibidos na saída do Plano de Execução referem-se ao número de vezes que o método **Init()** é chamado. A menos que um operador esteja no lado interno de uma junção de loop, **ActualRebinds** será igual a um e **ActualRewinds** será igual a zero. Se um operador estiver no lado interno de uma junção de loop, a soma do número de reassociações e retrocessos deve ser igual ao número de linhas processadas no lado externo da junção. Uma reassociação significa que um ou mais dos parâmetros correlatos da junção se alterou e o lado interno deve ser reavaliado. Um retrocesso significa que nenhum dos parâmetros correlatos se alterou e o conjunto de resultados interno anterior pode ser usado novamente.  
  
 **ActualRebinds** e **ActualRewinds** estão presentes na saída do Plano de Execução XML produzida usando a opção SET STATISTICS XML ON. Eles só são populados para os **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, e  **Função com valor de tabela** operadores. **ActualRebinds** e **ActualRewinds** também podem ser populados para os `Assert` e **filtro** operadores quando o **StartupExpression** atributo é definido como TRUE.  
  
 Quando **ActualRebinds** e **ActualRewinds** estiverem presentes em um Plano de Execução XML, serão comparáveis a **EstimateRebinds** e **EstimateRewinds**. Quando estiverem ausentes, o número estimado de linhas (**EstimateRows**) será comparável ao número de linhas real (**ActualRows**). Observe que a saída gráfica real do Plano de Execução exibe zeros para reassociações e retrocessos reais quando eles estão ausentes.  
  
 Um contador relacionado, **ActualEndOfScans**, só está disponível quando a saída do Plano de Execução é produzida usando a opção SET STATISTICS XML ON. Sempre que um operador físico chega ao término de seu fluxo de dados, esse contador é incrementado em um. Um operador físico pode chegar ao término de seu fluxo de dados zero, uma ou mais vezes. Como com as reassociações e os retrocessos, o número de término de exames só poderá ser superior a um se o operador estiver no lado interno de uma junção de loop. O número de término de exames deveria ser inferior ou igual à soma do número de reassociações e retrocessos.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapeando operadores físicos e lógicos  
 O otimizador de consulta cria um plano de consulta como uma árvore que consiste em operadores lógicos. Depois de criar o plano, o otimizador de consulta escolhe o operador físico mais eficiente para cada operador lógico. O otimizador de consulta usa uma abordagem baseada em custos para determinar qual operador físico implementará um operador lógico.  
  
 Normalmente, uma operação lógica pode ser implementada por diversos operadores físicos. Em alguns casos raros, porém, um operador físico também pode implementar diversas operações lógicas.  
  
## <a name="operator-descriptions"></a>Descrições dos operadores  
 Esta seção contém descrições dos operadores lógicos e físicos.  
  
|Ícone do plano de execução gráfica|Operador de plano de execução|Description|  
|-----------------------------------|-----------------------|-----------------|  
|Nenhum|`Aggregate`|O operador `Aggregate` calcula uma expressão que contém MIN, MAX, SUM, COUNT ou AVG. O operador `Aggregate` pode ser um operador lógico ou um operador físico.|  
|![Ícone do operador de expressão aritmética](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Ícone do operador de expressão aritmética")|`Arithmetic Expression`|O operador `Arithmetic Expression` computa um valor novo de valores existentes em uma linha. `Arithmetic Expression` não é usado em [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Ícone do operador Assert](../../2014/database-engine/media/assert-32x.gif "Ícone do operador Assert")|`Assert`|O `Assert` operador verifica uma condição. Por exemplo, ele valida integridade referencial ou assegura que uma subconsulta escalar retorne uma linha. Para cada linha de entrada, o `Assert` operador avalia a expressão no `Argument` coluna plano de execução. Se essa expressão for avaliada como NULL, a linha será passada pelo operador `Assert` e a execução de consulta continuará. Se essa expressão for avaliada como um valor não nulo, será gerado um erro apropriado. O `Assert` operador é um operador físico.|  
|![Ícone do elemento Atribuir linguagem](../../2014/database-engine/media/assign-32.gif "Ícone do elemento Atribuir linguagem")|`Assign`|O `Assign` operador atribui o valor de uma expressão ou constante a uma variável. `Assign` é um elemento de linguagem.|  
|Nenhum|`Asnyc Concat`|O `Asnyc Concat` operador é usado apenas em consultas remotas (consultas distribuídas). Ele tem *n* filhos e um nó pai. Normalmente, alguns dos filhos são computadores remotos que participam de uma consulta distribuída. `Asnyc Concat` problemas `open()` chama simultaneamente para todos os filhos e, em seguida, aplica um bitmap para cada filho. Para cada bit que é um 1, `Async Concat` envia linhas de saída para o nó pai sob demanda.|  
|![Ícone do operador de bitmap](../../2014/database-engine/media/bitmap-32x.gif "Ícone do operador de bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] usa o `Bitmap` operador para implementar filtro de bitmap em planos de consulta paralelos. Bitmap filtragem acelera a execução de consulta eliminando linhas com valores de chave que não podem produzir nenhum relatório de junção antes de transmitir as linhas por outro operador como o `Parallelism` operador. Um filtro de bitmap usa uma representação compacta de um conjunto de valores de uma tabela em uma parte da árvore de operador de uma segunda tabela em outra parte da árvore. Com a remoção de linhas desnecessárias previamente na consulta, os operadores subsequentes têm menos linhas para trabalhar e o desempenho geral da consulta melhora. O otimizador de consulta determina quando um bitmap é seletivo o bastante para ser útil e em quais operadores o filtro é aplicado. `Bitmap` é um operador físico.|  
|![Ícone do operador de bitmap](../../2014/database-engine/media/bitmap-32x.gif "Ícone do operador de bitmap")|`Bitmap Create`|O operador `Bitmap Create` aparece na saída do plano de execução onde os bitmaps são criados. `Bitmap Create` é um operador lógico.|  
|![Ícone do operador de pesquisa de indicador](../../2014/database-engine/media/bookmark-lookup-32x.gif "Ícone do operador de pesquisa de indicador")|`Bookmark Lookup`|O `Bookmark Lookup` operador usa um indicador (ID da linha ou chave de clustering) para pesquisar a linha correspondente na tabela ou índice clusterizado. O `Argument` coluna contém o rótulo de indicador usado para pesquisar a linha na tabela ou índice clusterizado. O `Argument` coluna também contém o nome da tabela ou índice clusterizado no qual a linha é procurada. Se a cláusula WITH PREFETCH aparecer no `Argument` coluna, o processador de consulta determinou que ele é ideal para usar pré-busca assíncrona (read-ahead) ao procurar indicadores na tabela ou índice clusterizado.<br /><br /> `Bookmark Lookup` não é usado em [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. Em vez disso, `Clustered Index Seek` e `RID Lookup` fornecem funcionalidade de indicador de pesquisa. O operador `Key Lookup` também fornece essa funcionalidade.|  
|Nenhum|`Branch Repartition`|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores `Parallelism` em uma região individual são chamados `Branch Repartition`. O iterador `Parallelism` no limite dessas duas regiões é chamado `Segment Repartition`. `Branch Repartition` e `Segment Repartition` são operadores lógicos.|  
|Nenhum|`Broadcast`|`Broadcast` tem um nó filho e *n* nós pai. `Broadcast` envia suas linhas de entrada para vários consumidores sob demanda. Cada consumidor adquire todas as linhas. Por exemplo, se todos os consumidores representarem lados de criação de uma junção hash, então serão criadas *n* cópias das tabelas de hash.|  
|![Ícone do operador para compilar hash](../../2014/database-engine/media/build-hash.gif "Ícone do operador para compilar hash")|`Build Hash`|Indica a criação de uma tabela de hash de lote para um índice columnstore xVelocity de memória otimizada.|  
|Nenhum|`Cache`|`Cache` é uma versão especializada do **Spool** operador. Ele armazena somente uma linha de dados. `Cache` é um operador lógico. `Cache` não é usado em [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Ícone do operador Excluir índice clusterizado](../../2014/database-engine/media/clustered-index-delete-32x.gif "Ícone do operador Excluir índice clusterizado")|`Clustered Index Delete`|O `Clustered Index Delete` operador exclui linhas de índice clusterizado especificado na coluna Argument do plano de execução de consulta. Se um predicado WHERE :() estiver presente na coluna argumento, em seguida, somente as linhas que atenderem ao predicado serão excluídas.`Clustered Index Delete` é um operador físico.|  
|![Ícone do operador Inserir índice clusterizado](../../2014/database-engine/media/clustered-index-insert-32x.gif "Ícone do operador Inserir índice clusterizado")|`Clustered Index Insert`|O `Clustered Index Insert` operador de plano de execução insere linhas de sua entrada no índice clusterizado especificado na coluna Argument. A coluna Argument também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se `Clustered Index Insert` não tiver nenhum filho para valores de inserção, a linha inserida será extraída do `Insert` próprio operador.`Clustered Index Insert` é um operador físico.|  
|![Ícone do operador Mesclar índice clusterizado](../../2014/database-engine/media/clustered-index-merge-32x.gif "Ícone do operador Mesclar índice clusterizado")|**Clustered Index Merge**|O operador **Clustered Index Merge** aplica um fluxo de mesclagem de dados a um índice clusterizado. O operador exclui, atualiza ou insere linhas do índice clusterizado especificado no `Argument` coluna do operador. A operação real executada depende do valor de tempo de execução a **ação** coluna especificada no `Argument` coluna do operador. **Clustered Index Merge** é um operador físico.|  
|![Ícone do operador Verificar índice clusterizado](../../2014/database-engine/media/clustered-index-scan-32x.gif "Ícone do operador Verificar índice clusterizado")|`Clustered Index Scan`|O `Clustered Index Scan` operador examina o índice clusterizado especificado na coluna Argument do plano de execução de consulta. Quando houver um predicado opcional WHERE:(), somente as linhas que atenderem ao predicado serão retornadas. Se a coluna Argument apresentar a cláusula ORDERED, o processador de consulta solicitou que a saída das linhas seja retornada na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento examinará o índice em modo ótimo, sem necessariamente classificar a saída. `Clustered Index Scan` é um operador lógico e físico.|  
|![Ícone do operador Buscar índice clusterizado](../../2014/database-engine/media/clustered-index-seek-32x.gif "Ícone do operador Buscar índice clusterizado")|`Clustered Index Seek`|O `Clustered Index Seek` operador usa a habilidade de busca de índices para recuperar linhas de um índice clusterizado. O `Argument` coluna contém o nome do índice clusterizado que está sendo usado e o predicado SEEK :(). O mecanismo de armazenamento usa o índice para processar somente as linhas que satisfazem esse predicado SEEK:(). Ele pode incluir também um predicado WHERE:(), onde o mecanismo de armazenamento avaliará em relação a todas as linhas que satisfizerem o predicado SEEK:(), mas isso é opcional e não usa índices para executar esse processo.<br /><br /> Se o `Argument` coluna contém a cláusula ORDERED, o processador de consulta determinou que as linhas fossem retornadas na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice em modo ótimo, sem necessariamente classificar a saída. Permitir que a saída retenha sua ordenação pode ser menos eficiente do que produzir saída não classificada. Quando a palavra-chave LOOKUP aparecer, então uma consulta de marcador está sendo executada. Na [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e versões posteriores, o `Key Lookup` operador fornece funcionalidade de bookmark lookup. `Clustered Index Seek` é um operador lógico e físico.|  
|![Ícone do operador Atualizar índice clusterizado](../../2014/database-engine/media/clustered-index-update-32x.gif "Ícone do operador Atualizar índice clusterizado")|`Clustered Index Update`|O `Clustered Index Update` operador atualiza linhas de entrada no índice clusterizado especificado no `Argument` coluna. Se um predicado WHERE :() estiver presente, somente as linhas que satisfazem esse predicado serão atualizadas. Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. Se um predicado DEFINE: () está presente, serão listados os valores que esse operador definir. Esses valores podem ser referenciados na cláusula SET ou em outro lugar dentro desse operador e em outro lugar dentro dessa consulta. `Clustered Index Update` é um operador lógico e físico.|  
|![Ícone do operador Recolher](../../2014/database-engine/media/collapse-32x.gif "ícone do operador Recolher")|`Collapse`|O operador `Collapse` otimiza processamento de atualização. Quando uma atualização é executada, ela pode ser dividida (usando o `Split` operador) em uma exclusão e uma inserção. O `Argument` coluna contém uma cláusula GROUP BY :() que especifica uma lista de colunas de chave. Se o processador de consultas encontrar linhas adjacentes que incluem e inserem os mesmos valores de chave, ele substituirá essas operações separadas por uma operação de atualização única e mais eficiente. `Collapse` é um operador lógico e físico.|  
|![Verificação de Índice Columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Verificação de Índice Columnstore")|`Columnstore Index Scan`|O `Columnstore Index Scan` operador examina o índice columnstore especificado no `Argument` coluna do plano de execução de consulta.|  
|![Ícone do operador Computar escalar](../../2014/database-engine/media/compute-scalar-32x.gif "Ícone do operador Computar escalar")|`Compute Scalar`|O `Compute Scalar` operador avalia uma expressão para produzir um valor escalar computado. Isso pode ser retornado ao usuário, ter referência em outro lugar na consulta, ou ambos. Um exemplo de ambos está em um predicado de filtro ou predicado de junção. `Compute Scalar` é um operador lógico e físico.<br /><br /> `Compute Scalar` os operadores que aparecem em planos de execução gerados por SET STATISTICS XML não podem conter o `RunTimeInformation` elemento. Em planos de execução gráficos, **Linhas Reais**, **Religações Reais**e **Retrocessos Reais** podem estar ausentes na janela **Propriedades** quando a opção **Incluir Plano de Execução Real** estiver selecionada em [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Quando isto acontece, significa que, embora os operadores tenham sido usados no plano de consulta compilado, o trabalho foi executado por outros operadores no plano de consulta de tempo de execução. Observe também que o número de execuções na saída de plano de execução gerada por SET STATISTICS PROFILE é equivalente à soma de reassociações e retrocessos em planos de execução gerados por SET STATISTICS XML.|  
|![Ícone do operador Concatenação](../../2014/database-engine/media/concatenation-32x.gif "Ícone do operador Concatenação")|**Concatenation**|O operador **Concatenation** verifica várias entradas, retornando cada linha verificada. **Concatenation** normalmente é usado para implementar a construção UNION ALL [!INCLUDE[tsql](../includes/tsql-md.md)] . O operador físico **Concatenation** tem duas ou mais entradas e uma saída. Concatenation copia linhas do primeiro fluxo de entrada ao fluxo de saída e repete essa operação para cada fluxo de entrada adicional. **Concatenation** é um operador lógico e físico.|  
|![Ícone do operador Verificação de constante](../../2014/database-engine/media/constant-scan-32x.gif "Ícone do operador Verificação de constante")|`Constant Scan`|O `Constant Scan` operador introduz uma ou mais linhas constantes em uma consulta. Um `Compute Scalar` operador é frequentemente usado após uma `Constant Scan` para adicionar colunas a uma linha produzida pelo `Constant Scan` operador.|  
|![Ícone de elemento de linguagem Converter (Mecanismo de Banco de Dados)](../../2014/database-engine/media/convert-32x.gif "Ícone de elemento de linguagem Converter (Mecanismo de Banco de Dados)")|`Convert`|O operador `Convert` converte um tipo de dados escalar em outro. `Convert` é um elemento de linguagem.|  
|Nenhum|`Cross Join`|O operador `Cross Join` une cada linha da primeira entrada (superior) a cada linha da segunda entrada (inferior). `Cross Join` é um operador lógico.|  
|![Ícone do operador de cursor Cursor catchall](../../2014/database-engine/media/cursor-catch-all.gif "Ícone do operador de cursor Cursor catchall")|`catchall`|O ícone catchall é exibido quando a lógica que produz planos de execução gráficos não puder encontrar um ícone viável para o iterador. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para elementos de linguagem [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|Nenhum|**Cursor**|Os operadores lógicos e físicos **Cursor** são usados para descrever como é executada uma consulta ou atualização que envolva operações de cursor. Os operadores físicos descrevem o algoritmo de implementação físico usado para processar o cursor; por exemplo, usando um cursor controlado por conjunto de chaves. Cada etapa na execução de um cursor envolve um operador físico. Os operadores lógicos descrevem uma propriedade do cursor, como quando o cursor é somente leitura.<br /><br /> Operadores lógicos incluem Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary e Synchronous.<br /><br /> Operadores físicos incluem Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.|  
|![Ícone do elemento Declarar linguagem](../../2014/database-engine/media/declare-32x.gif "Ícone do elemento Declarar linguagem")|`Declare`|O `Declare` operador aloca uma variável local no plano de consulta. `Declare` é um elemento de linguagem.|  
|![Ícone do operador Excluir (Mecanismo de Banco de Dados)](../../2014/database-engine/media/delete-32x.gif "Ícone do operador Excluir (Mecanismo de Banco de Dados)")|`Delete`|O `Delete` operador exclui um objeto em linhas de que atendem ao predicado opcional no `Argument` coluna.|  
|![Ícone do operador Excluir verificação](../../2014/database-engine/media/delete-scan-32x.gif "Ícone do operador Excluir verificação")|`Deleted Scan`|O operador `Deleted Scan` examina a tabela excluída em um gatilho.|  
|Nenhum|`Distinct`|O operador `Distinct` remove duplicatas de um conjunto de linhas ou de uma coleção de valores. `Distinct` é um operador lógico.|  
|Nenhum|`Distinct Sort`|O `Distinct Sort` operador lógico examina a entrada, removendo duplicatas e fazendo classificação pelas colunas especificadas na DISTINCT ORDER BY :() predicado do `Argument` coluna. `Distinct Sort` é um operador lógico.|  
|![Ícone do operador Distribuir paralelismo de fluxos](../../2014/database-engine/media/parallelism-distribute-stream.gif "Ícone do operador Distribuir paralelismo de fluxos")|**Distribute Streams**|O operador **Distribute Streams** só é usado em planos de consulta paralelos. O operador **Distribute Streams** leva um fluxo de entrada simples de registros e produz fluxos de saída múltiplos. O conteúdo do registro e o formato não são alterados. Cada registro do fluxo de entrada aparece em um dos fluxos de saída. Este operador preserva automaticamente a ordem relativa dos registros de entrada nos fluxos de saída. Normalmente, são usadas operações de hash para decidir a qual fluxo de saída pertence um determinado registro de entrada.<br /><br /> Se a saída for particionada, então o `Argument` coluna contém um predicado PARTITION COLUMNS :() e as colunas de particionamento. **Distribute Streams** é um operador lógico|  
|![Ícone do operador de cursor dinâmico](../../2014/database-engine/media/dynamic-32x.gif "Ícone do operador de cursor dinâmico")|`Dynamic`|O `Dynamic` operador usa um cursor que pode ver todas as alterações feitas por outras pessoas.|  
|![Ícone do operador spool](../../2014/database-engine/media/spool-32x.gif "Ícone do operador spool")|**Eager Spool**|O **Eager Spool** operador usa toda a entrada, armazenando cada linha em um objeto temporário oculto armazenado no `tempdb` banco de dados. Se for feito o retrocesso do operador (por exemplo, por um `Nested Loops` operador), mas a reassociação for necessária, os dados em spool são usados em vez de novo exame da entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Eager Spool** cria seu arquivo de spool de maneira “ávida”, ou seja, cada vez que o operador pai do spool solicita a primeira linha, o operador de spool consome todas as linhas de seu operador de entrada e as armazena no spool. O**Eager Spool** é um operador lógico.|  
|![Ícone do operador Buscar cursor de consulta](../../2014/database-engine/media/fetch-query-32x.gif "Ícone do operador Buscar cursor de consulta")|`Fetch Query`|O `Fetch Query` operador recupera linhas quando é feita uma busca em um cursor.|  
|![Ícone do operador Filtrar (Mecanismo de Banco de Dados)](../../2014/database-engine/media/filter-32x.gif "Ícone do operador Filtrar (Mecanismo de Banco de Dados)")|**Filter**|O **filtro** operador examina a entrada, retornando apenas as linhas que satisfazem a expressão de filtro (predicado) que aparece no `Argument` coluna.|  
|Nenhum|`Flow Distinct`|O `Flow Distinct` operador lógico examina a entrada, removendo duplicatas. Enquanto o `Distinct` operador consome toda a entrada antes de produzir qualquer saída, o **FlowDistinct** operador retorna cada linha como foi obtida da entrada (a menos que essa linha é uma duplicata, caso em que ela é descartada).|  
|Nenhum|`Full Outer Join`|O `Full Outer Join` operador lógico retorna cada linha que satisfaz o predicado de junção da primeira (superior) entrada associada a cada linha da segunda (inferior) entrada. Ele também retorna linhas:<br /><br /> - Da primeira entrada que não teve nenhuma correspondência na segunda entrada.<br /><br /> - Da segunda entrada que não teve nenhuma correspondência na primeira entrada.<br /><br /> <br /><br /> A entrada que não contém os valores correspondentes é retornada como um valor nulo. `Full Outer Join` é um operador lógico.|  
|![Ícone do operador Coletar paralelismo de fluxos](../../2014/database-engine/media/parallelism-32x.gif "Ícone do operador Coletar paralelismo de fluxos")|**Gather Streams**|O operador **Gather Streams** só é usado em planos de consulta paralelos. O operador **Gather Streams** consome vários fluxos de entrada e produz um único fluxo de saída de registros ao combinar os fluxos de entrada. O conteúdo do registro e o formato não são alterados. Se este operador for preservador da ordem, todos os fluxos de entrada deverão ser ordenados. Se a saída for ordenada, a `Argument` coluna contém um predicado ORDER BY :() e os nomes das colunas que estão sendo ordenadas. **Gather Streams** é um operador lógico.|  
|![Ícone do operador Correspondência de hash](../../2014/database-engine/media/hash-match-32x.gif "Ícone do operador Correspondência de hash")|`Hash Match`|O operador `Hash Match` cria uma tabela de hash computando um valor de hash para cada linha da entrada criada. Um predicado HASH :() com uma lista de colunas usadas para criar um valor de hash aparece no `Argument` coluna. Então, para cada fila de sondagem (conforme aplicável), ela computa um valor de hash (usando a mesma função de hash) e procura correspondências na tabela de hash. Se um predicado residual estiver presente (identificado por RESIDUAL :() no `Argument` coluna), esse predicado também deverá ser atendido para as linhas sejam consideradas uma correspondência. O comportamento depende da operação lógica que está sendo executada:<br /><br /> Para qualquer junção, use a primeira entrada (superior) para criar a tabela de hash e a segunda (inferior) para sondar a tabela de hash. As correspondências de saída (ou não correspondências) conforme determinadas pelo tipo de junção. Se várias junções usam a mesma coluna de junção, essas operações serão agrupadas em uma equipe de hash.<br /><br /> Para os operadores distintos ou de agregação, use a entrada para criar a tabela de hash (removendo duplicatas e computando quaisquer expressões de agregação). Quando a tabela de hash for criada, verifique a tabela e saída de todas as entradas.<br /><br /> Para o operador de união, use a primeira entrada para criar a tabela de hash (removendo duplicatas). Use a segunda entrada (que não deve ter uma duplicata) para sondar a tabela de hash, retornando todas linhas sem correspondência e, então, verifique a tabela de hash e retorne todas as entradas.<br /><br /> <br /><br /> `Hash Match` é um operador físico.|  
|![Ícone do elemento de linguagem If](../../2014/database-engine/media/if-32x.gif "Ícone do elemento de linguagem If")|`If`|O `If` operador executa processamento condicional com base em uma expressão. `If` é um elemento de linguagem.|  
|Nenhum|`Inner Join`|O `Inner Join` operador lógico retorna cada linha que satisfaz a junção da primeira entrada (superior) com a segunda (inferior) entrada.|  
|![Ícone do operador Inserir (Mecanismo de Banco de Dados)](../../2014/database-engine/media/insert-32x.gif "Ícone do operador Inserir (Mecanismo de Banco de Dados)")|`Insert`|O `Insert` operador lógico insere cada linha de sua entrada no objeto especificado no `Argument` coluna. O operador físico é o `Table Insert`, `Index Insert`, ou `Clustered Index Insert` operador.|  
|![Ícone do operador Verificação inserida](../../2014/database-engine/media/inserted-scan-32x.gif "Ícone do operador Verificação inserida")|**Inserted Scan**|O operador **Inserted Scan** verifica a tabela **inserida** . O**Inserted Scan** é um operador lógico e físico.|  
|![Ícone do elemento de linguagem intrínseca](../../2014/database-engine/media/intrinsic-32x.gif "Ícone do elemento de linguagem intrínseca")|`Intrinsic`|O `Intrinsic` operador invoca interno [!INCLUDE[tsql](../includes/tsql-md.md)] função. `Intrinsic` é um elemento de linguagem.|  
|![Ícone do operador catchall de iterador](../../2014/database-engine/media/iterator-catch-all.gif "Ícone do operador catchall de iterador")|`Iterator`|O ícone catchall `Iterator` é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Ícone do operador de pesquisa de indicador](../../2014/database-engine/media/bookmark-lookup-32x.gif "Ícone do operador de pesquisa de indicador")|`Key Lookup`|O `Key Lookup` operador é um indicador de pesquisa em uma tabela com um índice clusterizado. O `Argument` coluna contém o nome do índice clusterizado e a chave de Clusterização usada para pesquisar a linha no índice clusterizado. `Key Lookup` sempre é acompanhado por um `Nested Loops` operador. Se a cláusula WITH PREFETCH aparecer no `Argument` coluna, o processador de consulta determinou que ele é ideal para usar pré-busca assíncrona (read-ahead) ao observar marcadores no índice clusterizado.<br /><br /> O uso de um `Key Lookup` operador em um plano de consulta indica que a consulta pode se beneficiar de ajuste de desempenho. Por exemplo, o desempenho da consulta pode ser melhorado adicionando-se um índice de cobertura.|  
|![Ícone do operador de cursor de conjunto de chaves](../../2014/database-engine/media/keyset-32x.gif "Ícone do operador de cursor de conjunto de chaves")|`Keyset`|O operador `Keyset` usa um cursor que pode visualizar atualizações, mas não inserções feitas por outros.|  
|![Ícone catchall de elemento de linguagem](../../2014/database-engine/media/language-construct-catch-all.gif "Ícone catchall de elemento de linguagem")|`Language Element`|O ícone catchall `Language Element` é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Ícone do operador spool](../../2014/database-engine/media/spool-32x.gif "Ícone do operador spool")|**Lazy Spool**|O **Lazy Spool** operador lógico armazena cada linha de sua entrada em um objeto temporário oculto armazenado no `tempdb` banco de dados. Se for feito o retrocesso do operador (por exemplo, por um `Nested Loops` operador), mas a reassociação for necessária, os dados em spool são usados em vez de novo exame da entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Lazy Spool** cria seu arquivo de spool de maneira “lenta”, ou seja, sempre que o operador pai do spool solicita uma linha, o operador do spool obtém uma linha de seu operador de entrada e a armazena no spool, em vez de consumir todas as linhas de uma vez. O Lazy Spool é um operador lógico.|  
|Nenhum|`Left Anti Semi Join`|O operador `Left Anti Semi Join` retorna cada linha da primeira entrada (parte superior) quando não existe uma linha correspondente na segunda entrada (parte inferior). Se não houver nenhum predicado de junção no `Argument` coluna, cada linha é uma linha correspondente. `Left Anti Semi Join` é um operador lógico.|  
|Nenhum|`Left Outer Join`|O operador `Left Outer Join` retorna cada linha que satisfaz a junção da primeira entrada (parte superior) com a segunda entrada (parte inferior). Ele também retorna linhas da primeira entrada que não teve linhas correspondentes na segunda entrada. As linhas não correspondentes na segunda entrada são retornadas como valores nulos. Se não houver nenhum predicado de junção no `Argument` coluna, cada linha é uma linha correspondente. `Left Outer Join` é um operador lógico.|  
|Nenhum|`Left Semi Join`|O `Left Semi Join` operador retorna cada linha da primeira entrada (superior) quando há uma linha correspondente na segunda entrada (inferior). Se não houver nenhum predicado de junção no `Argument` coluna, cada linha é uma linha correspondente. `Left Semi Join` é um operador lógico.|  
|![Ícone do operador Registrar verificação de linha](../../2014/database-engine/media/log-row-scan-32x.gif "Ícone do operador Registrar verificação de linha")|`Log Row Scan`|O `Log Row Scan` operador examina o log de transações. `Log Row Scan` é um operador lógico e físico.|  
|![Ícone do operador Mesclar intervalo](../../2014/database-engine/media/merge-interval-32x.gif "Ícone do operador Mesclar intervalo")|`Merge Interval`|O `Merge Interval` operador mescla vários intervalos (com sobreposição potencial) para produzir intervalos mínimo, que não se sobrepõem, em seguida, são usados para buscar entradas de índice. Esse operador aparece geralmente sobre um ou mais `Compute Scalar` operadores sobre `Constant Scan` operadores, que constroem os intervalos (representados como colunas em uma linha) que esse operador mescla. `Merge Interval` é um operador lógico e físico.|  
|![Ícone do operador Mesclar junção](../../2014/database-engine/media/merge-join-32x.gif "Ícone do operador Mesclar junção")|**Junção de Mesclagem**|O operador **Merge Join** executa a inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e operações lógicas de união.<br /><br /> No `Argument` coluna, o **Merge Join** operador contém um predicado MERGE :() se a operação estiver executando uma junção um-para-muitos ou um para muitos MERGE :() predicado se a operação estiver executando uma junção de muitos-para-muitos. O `Argument` coluna também inclui uma lista separada por vírgulas de colunas usado para executar a operação. O operador **Merge Join** requer duas entradas classificadas em suas respectivas colunas, possivelmente inserindo operações de classificação explícitas no plano de consulta. A junção de mesclagem é particularmente eficaz se não for exigida uma classificação explícita, por exemplo, se houver um índice da árvore B adequado no banco de dados, ou se a ordem de classificação puder ser explorada para diversas operações, como uma junção de mesclagem e um agrupamento com acúmulo. **Merge Join** é um operador físico.|  
|![Ícone do operador Loops aninhados](../../2014/database-engine/media/nested-loops-32x.gif "Ícone do operador Loops aninhados")|`Nested Loops`|O operador `Nested Loops` executa operações lógicas de junção interna, junção externa esquerda, left semi join e left anti semi join. As junções de loops aninhados executam uma pesquisa na tabela interna para cada linha da tabela externa, normalmente usando um índice. O processador de consultas decide, com base em custos previstos, se classificará a entrada externa para aprimorar a localidade das pesquisas no índice da entrada interna. Quaisquer linhas que atenderem ao predicado (opcional) na `Argument` coluna é retornada como aplicável, com base na operação lógica que está sendo executada. `Nested Loops` é um operador físico.|  
|![Ícone do operador Excluir índice não clusterizado](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Ícone do operador Excluir índice não clusterizado")|`Nonclustered Index Delete`|O `Nonclustered Index Delete` operador exclui linhas de entrada de índice não clusterizado especificado no `Argument` coluna. `Nonclustered Index Delete` é um operador físico.|  
|![Ícone do operador Inserir índice não clusterizado](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Ícone do operador Inserir índice não clusterizado")|`Index Insert`|O `Index Insert` operador insere linhas de sua entrada no índice não clusterizado especificado no `Argument` coluna. O `Argument` coluna também contém um predicado SET :(), que indica o valor para o qual cada coluna está definida. `Index Insert` é um operador físico.|  
|![Ícone do operador Verificar índice não clusterizado](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Ícone do operador Verificar índice não clusterizado")|`Index Scan`|O `Index Scan` operador recupera todas as linhas do índice não clusterizado especificado no `Argument` coluna. Se um predicado opcional WHERE :() aparecer no `Argument` coluna, somente as linhas que atenderem ao predicado são retornadas. `Index Scan` é um operador lógico e físico.|  
|![Ícone do operador Buscar índice não clusterizado](../../2014/database-engine/media/index-seek-32x.gif "Ícone do operador Buscar índice não clusterizado")|`Index Seek`|O `Index Seek` operador usa a habilidade de busca de índices para recuperar linhas de um índice não clusterizado. O `Argument` coluna contém o nome do índice não clusterizado que está sendo usado. Também contém o predicado SEEK:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que atendem ao predicado SEEK:(). Ele pode incluir opcionalmente um predicado WHERE:(), que o mecanismo de armazenamento avaliará em relação a todas as linhas que atenderem ao predicado SEEK:() (não usa os índices para fazer isso). Se o `Argument` coluna contém a cláusula ORDERED, o processador de consulta determinou que as linhas fossem retornadas na ordem em que o índice não clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice no modo ideal (o que não garante que a saída será classificada). Permitir que a saída retenha sua ordenação pode ser menos eficiente que produzir saída não classificada. `Index Seek` é um operador lógico e físico.|  
|![Ícone do operador Spool de índice não clusterizado](../../2014/database-engine/media/index-spool-32x.gif "Ícone do operador Spool de índice não clusterizado")|**Index Spool**|O **Index Spool** operador físico contém um predicado SEEK :() no `Argument` coluna. O **Index Spool** operador examina suas linhas de entrada, colocando uma cópia de cada linha em um arquivo spool oculto (armazenado no `tempdb` banco de dados e existente o tempo de vida da consulta) e cria um índice não clusterizado nas linhas. Isto permite que você use o recurso de busca de índices para produzir somente as linhas que correspondem ao predicado SEEK: (). Se for feito o retrocesso do operador (por exemplo, por um `Nested Loops` operador), mas a reassociação for necessária, os dados em spool são usados em vez de novo exame da entrada.|  
|![Ícone do operador Atualizar índice não clusterizado](../../2014/database-engine/media/nonclust-index-update-32x.gif "Ícone do operador Atualizar índice não clusterizado")|`Nonclustered Index Update`|O `Nonclustered Index Update` operador físico atualiza linhas de sua entrada no índice não clusterizado especificado no `Argument` coluna. Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. `Nonclustered Index Update` é um operador físico.|  
|![Ícone do operador Inserir índice online](../../2014/database-engine/media/online-index-32x.gif "Ícone do operador Inserir índice online")|**Online Index Insert**|O operador físico **Online Index Insert** indica que uma operação de criação, alteração ou remoção de índice é executada online. Ou seja, os dados da tabela subjacente permanecem disponíveis para usuários durante a operação de índice.|  
|Nenhum|`Parallelism`|O `Parallelism` operador executa fluxos de distribuição, coleta e repartição operações lógicas. O `Argument` colunas podem conter um predicado PARTITION COLUMNS :() com uma lista separada por vírgulas das colunas que estão sendo particionadas. O `Argument` colunas também podem conter um predicado ORDER BY :(), listando as colunas para preservar a ordem de classificação durante o particionamento. `Parallelism` é um operador físico.<br /><br /> Observação: Se uma consulta tiver sido compilada como paralela, mas no tempo de execução for executada como consulta serial, o plano de execução saída gerada por SET STATISTICS XML ou usando o **Include Actual Execution Plan** opção [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] não conterá o `RunTimeInformation` elemento para o `Parallelism` operador. Na saída SET STATISTICS PROFILE, contagens de linhas reais e número real de execuções exibirão zeros para o `Parallelism` operador. Quando uma dessas condições ocorre, significa que o `Parallelism` operador só foi usado durante a compilação de consulta e não no plano de consulta de tempo de execução. Observe que às vezes os planos de consulta paralelos serão executados em série, se houver uma carga simultânea grande no servidor.|  
|![Ícone do operador Verificar tabela de parâmetro](../../2014/database-engine/media/parameter-table-scan-32x.gif "Ícone do operador Verificar tabela de parâmetro")|`Parameter Table Scan`|O `Parameter Table Scan` operador examina uma tabela que está atuando como um parâmetro na consulta atual. Normalmente, isto é usado para consultas INSERT dentro de um procedimento armazenado. `Parameter Table Scan` é um operador lógico e físico.|  
|Nenhum|**Partial Aggregate**|**Agregação parcial** é usada em planos paralelos. Aplica uma função de agregação para tantas linhas de entrada quanto possíveis de forma que gravar em disco (conhecido como "derramamento") não é necessário. `Hash Match` é o único operador físico (iterator) que implementa a agregação de partição. **Agregação parcial** é um operador lógico.|  
|![Ícone do operador Cursor de consulta de população](../../2014/database-engine/media/poulation-query-32x.gif "Ícone do operador Cursor de consulta de população")|`Population Query`|O operador `Population Query` popula a tabela de trabalho de um cursor quando o cursor é aberto.|  
|![Ícone do operador Atualizar cursor de consulta](../../2014/database-engine/media/refresh-query-32x.gif "Ícone do operador Atualizar cursor de consulta")|`Refresh Query`|O operador `Refresh Query` busca dados atuais para linhas do buffer de busca.|  
|![Ícone do operador Exclusão remota](../../2014/database-engine/media/remote-delete-32x.gif "Ícone do operador Exclusão remota")|`Remote Delete`|O `Remote Delete` operador exclui as linhas de entrada de um objeto remoto. `Remote Delete` é um operador lógico e físico.|  
|![Operador de plano de execução Buscar índice remoto](../../2014/database-engine/media/remote-index-scan-32x.gif "Operador de plano de execução Buscar índice remoto")|**Remote Index Scan**|O operador **Remote Index Scan** examina o índice remoto especificado na coluna Argument. **Verificação de Índice Remoto** é um operador lógico e físico.|  
|![Operador de plano de execução Buscar índice remoto](../../2014/database-engine/media/remote-index-seek-32x.gif "Operador de plano de execução Buscar índice remoto")|**Remote Index Seek**|O operador de **Busca de Índice Remoto** usa a busca de um objeto de índice remoto para recuperar linhas. O `Argument` coluna contém o nome do índice remoto que está sendo usado e o predicado SEEK :(). **Busca de Índice Remoto** é um operador lógico e físico.|  
|![Ícone do operador Inserção remota](../../2014/database-engine/media/remote-insert-32x.gif "Ícone do operador Inserção remota")|**Remote Insert**|O operador **Remote Insert** insere linhas de entrada em um objeto remoto. O**Remote Insert** é um operador lógico e físico.|  
|![Ícone do operador Consulta remota](../../2014/database-engine/media/remote-query-32x.gif "Ícone do operador Consulta remota")|`Remote Query`|O `Remote Query` operador envia uma consulta a uma fonte remota. O texto da consulta enviado ao servidor remoto aparece no `Argument` coluna. `Remote Query` é um operador lógico e físico.|  
|![Ícone do operador Verificação remota](../../2014/database-engine/media/remote-scan-32x.gif "Ícone do operador Verificação remota")|`Remote Scan`|O `Remote Scan` operador examina um objeto remoto. O nome do objeto remoto aparece no `Argument` coluna. `Remote Scan` é um operador lógico e físico.|  
|![Ícone do operador Atualização remota](../../2014/database-engine/media/remote-update-32x.gif "Ícone do operador Atualização remota")|`Remote Update`|O `Remote Update` operador atualiza as linhas de entrada em um objeto remoto. `Remote Update` é um operador lógico e físico.|  
|![Ícone do operador Reparticionar paralelismo de fluxos](../../2014/database-engine/media/parallelism-repartition-stream.gif "Ícone do operador Reparticionar paralelismo de fluxos")|**Repartition Streams**|O operador **Reparticionar Fluxos** consome vários fluxos e produz vários fluxos de registros. O conteúdo do registro e o formato não são alterados. Se o otimizador de consulta usar um filtro de bitmap, o número de linhas no fluxo de saída será reduzido. Cada registro de um fluxo de entrada é colocado em um fluxo de saída. Se esse operador for preservador de ordem, todos os fluxos de entrada deverão ser ordenados e mesclados em vários fluxos de saída ordenados. Se a saída for particionada, o `Argument` coluna contém um predicado PARTITION COLUMNS :() e as colunas de particionamento. Se a saída for ordenada, a `Argument` coluna contém um predicado ORDER BY :() e as colunas que estão sendo ordenadas. **Reparticionar Fluxos** atua como um operador lógico. O operador é usado somente em planos de consulta paralelos.|  
|![Ícone do elemento Linguagem do resultado](../../2014/database-engine/media/result-32x.gif "Ícone do elemento Linguagem do resultado")|`Result`|O `Result` operador consiste nos dados retornados no final de um plano de consulta. Normalmente, é o elemento raiz de um plano de execução. `Result` é um elemento de linguagem.|  
|![Ícone do operador Pesquisa de RID](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Ícone do operador Pesquisa de RID")|`RID Lookup`|`RID Lookup` um indicador de pesquisa em um heap está usando um identificador de linha fornecido (RID). O `Argument` coluna contém o rótulo de indicador usado para pesquisar a linha na tabela e o nome da tabela na qual a linha é procurada. `RID Lookup` sempre é acompanhado por NESTED LOOP JOIN. `RID Lookup` é um operador físico. Para obter mais informações sobre pesquisas de indicador, consulte o artigo sobre[pesquisa de indicadores](http://go.microsoft.com/fwlink/?LinkId=132568)no blog do SQL Server no MSDN.|  
|Nenhum|`Right Anti Semi Join`|O `Right Anti Semi Join` operador saída de cada linha da segunda entrada (inferior) quando uma linha correspondente na primeira (superior) entrada não existe. Uma linha correspondente é definida como uma linha que satisfaz o predicado a `Argument` coluna (se nenhum predicado existir, cada linha é uma linha correspondente). `Right Anti Semi Join` é um operador lógico.|  
|Nenhum|`Right Outer Join`|O `Right Outer Join` operador retorna cada linha que satisfaz a junção da segunda (inferior) entrada com cada linha correspondente da primeira (superior) entrada. Ele também retorna linhas da segunda entrada que não tiveram linhas correspondentes na primeira entrada, unidas com NULL. Se não houver nenhum predicado de junção no `Argument` coluna, cada linha é uma linha correspondente. `Right Outer Join` é um operador lógico.|  
|Nenhum|`Right Semi Join`|O operador `Right Semi Join` retornará todas as linha da segunda entrada (inferior) quando existir uma linha correspondente na primeira entrada (superior). Se não houver nenhum predicado de junção no `Argument` coluna, cada linha é uma linha correspondente. `Right Semi Join` é um operador lógico.|  
|![Ícone do operador Spool de contagem de linha](../../2014/database-engine/media/remote-count-spool-32x.gif "Ícone do operador Spool de contagem de linha")|**Row Count Spool**|O operador **Row Count Spool** examina a entrada, contando quantas linhas estão presentes e retornando o mesmo número de linhas sem qualquer dado nelas. Esse operador é usado quando é importante a verificação da existência de linhas, em vez dos dados contidos nas linhas. Por exemplo, se um `Nested Loops` operador executa uma operação left semi join e o predicado de junção se aplica à entrada interna, um spool de contagem de linhas pode ser colocado no topo da entrada interna do `Nested Loops` operador. Em seguida, a `Nested Loops` operador pode determinar quantas linhas saem do spool de contagem de linha de (porque os dados reais do lado interno não são necessários) para determinar se retornará a linha exterior. O**Row Count Spool** é um operador físico.|  
|![Ícone do operador Segmento](../../2014/database-engine/media/segment-32x.gif "Ícone do operador Segmento")|**Segment**|**Segment** é um operador lógico e físico. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. Essas colunas são mostradas como argumentos no operador **Segment** . O operador produz então um segmento por vez.|  
|Nenhum|`Segment Repartition`|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores `Parallelism` em uma região individual são chamados `Branch Repartition`. O iterador `Parallelism` no limite dessas duas regiões é chamado `Segment Repartition`. `Branch Repartition` e `Segment Repartition` são operadores lógicos.|  
|![Ícone do operador Sequência](../../2014/database-engine/media/sequence-32x.gif "Ícone do operador Sequência")|`Sequence`|O `Sequence` operador conduz amplos planos de atualização. Em termos funcionais, ele executa cada entrada em sequência (da parte superior até a inferior). Cada entrada normalmente é uma atualização de um objeto diferente. Ele retorna somente as linhas que vêm de sua última entrada (parte inferior). `Sequence` é um operador lógico e físico.|  
|![Ícone do operador Projeto de sequência](../../2014/database-engine/media/sequence-project-32x.gif "Ícone do operador Projeto de sequência")|`Sequence Project`|O `Sequence Project` operador adiciona colunas para executar computações sobre um conjunto ordenado. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. O operador produz então um segmento por vez. Estas colunas são mostradas como argumentos no operador `Sequence Project`. `Sequence Project` é um operador lógico e físico.|  
|![Ícone do operador Cursor de instantâneo](../../2014/database-engine/media/snapshot-32x.gif "Ícone do operador Cursor de instantâneo")|**Instantâneo**|O operador **Snapshot** cria um cursor que não encontra mudanças feitas pelos outros.|  
|![Ícone do operador Classificar](../../2014/database-engine/media/sort-32x.gif "Ícone do operador Classificar")|`Sort`|O `Sort` operador classifica todas as linhas de entrada. O `Argument` coluna contém um DISTINTOS predicado ORDER BY :() se duplicatas forem removidas por esta operação ou um predicado ORDER BY :() com uma lista separada por vírgulas das colunas sendo classificadas. As colunas são prefixadas com o valor ASC se as colunas forem classificadas em ordem crescente, ou o valor DESC se as colunas forem classificadas em ordem decrescente. `Sort` é um operador lógico e físico.|  
|![Ícone do operador Dividir](../../2014/database-engine/media/split-32x.gif "Ícone do operador Dividir")|`Split`|O `Split` operador é usado para otimizar o processamento de atualização. Ele divide cada operação de atualização em uma operação de exclusão e inserção. `Split` é um operador lógico e físico.|  
|![Ícone do operador spool](../../2014/database-engine/media/spool-32x.gif "Ícone do operador spool")|**Spool**|O **Spool** operador salva um resultado de consulta intermediário a `tempdb` banco de dados.|  
|![Ícone do operador Agregação de fluxo](../../2014/database-engine/media/stream-aggregate-32x.gif "Ícone do operador Agregação de fluxo")|`Stream Aggregate`|O `Stream Aggregate` operador agrupa linhas através de uma ou mais colunas e, em seguida, calcula uma ou mais expressões de agregação retornadas pela consulta. A saída deste operador pode ser referenciada por operadores posteriores na consulta, retornada ao cliente, ou ambos. O operador `Stream Aggregate` requer a entrada de dados ordenada pelas colunas dentro de seus grupos. O otimizador usará um operador `Sort` antes desse operador se os dados ainda não estiverem classificados em função de um operador `Sort` anterior ou devido a uma busca ou análise de índice ordenado. Na instrução SHOWPLAN_ALL ou no plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], as colunas no predicado GROUP BY são listadas na `Argument` coluna e as expressões de agregação são listadas na **valores definidos pelo** coluna. `Stream Aggregate` é um operador físico.|  
|![Ícone do operador Comutador](../../2014/database-engine/media/switch-32x.gif "Ícone do operador Comutador")|**Opção**|**Switch** é um tipo especial de iterador de concatenação que tem *n* entradas. Uma expressão é associada a cada operador **Switch** . Dependendo do valor retornado da expressão (entre 0 e *n*-1), **Switch** copia o fluxo de entrada apropriado ao fluxo de saída. Um uso de **Switch** é implementar planos de consulta envolvendo cursores de avanço rápido com determinados operadores, como o operador **TOP** . **Switch** é um operador lógico e físico.|  
|![Ícone do operador Exclusão de tabela](../../2014/database-engine/media/table-delete-32x.gif "Ícone do operador Exclusão de tabela")|`Table Delete`|O `Table Delete` operador físico exclui linhas da tabela especificada no `Argument` coluna do plano de execução de consulta.|  
|![Ícone do operador Inserção de tabela](../../2014/database-engine/media/table-insert-32x.gif "Ícone do operador Inserção de tabela")|`Table Insert`|O `Table Insert` operador insere linhas de sua entrada na tabela especificada no `Argument` coluna do plano de execução de consulta. O `Argument` coluna também contém um predicado SET :(), que indica o valor para o qual cada coluna está definida. Se `Table Insert` não tiver nenhum filho para valores de inserção e, em seguida, a linha inserida será tirada do próprio operador Insert. `Table Insert` é um operador físico.|  
|![Operador Mesclar tabela](../../2014/database-engine/media/table-merge-32x.gif "Operador Mesclar tabela")|**Table Merge**|O operador **Table Merge** aplica um fluxo de dados de mesclagem a um heap. O operador exclui, atualiza ou insere linhas na tabela especificada no `Argument` coluna do operador. A operação real executada depende do valor de tempo de execução a **ação** coluna especificada no `Argument` coluna do operador. **Table Merge** é um operador físico.|  
|![Ícone do operador Verificação de tabela](../../2014/database-engine/media/table-scan-32x.gif "Ícone do operador Verificação de tabela")|`Table Scan`|O `Table Scan` operador recupera todas as linhas da tabela especificada no `Argument` coluna do plano de execução de consulta. Se um predicado WHERE :() aparecer no `Argument` coluna, somente as linhas que atenderem ao predicado são retornadas. `Table Scan` é um operador lógico e físico.|  
|![Ícone do operador Spool de tabela](../../2014/database-engine/media/table-spool-32x.gif "Ícone do operador Spool de tabela")|**Table Spool**|O operador **Table Spool** examina a entrada e coloca uma cópia de cada linha em uma tabela de spool oculta que é armazenada no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) e existe durante o tempo de vida da consulta. Se for feito o retrocesso do operador (por exemplo, por um `Nested Loops` operador), mas a reassociação for necessária, os dados em spool são usados em vez de novo exame da entrada. **Table Spool** é um operador físico.|  
|![Ícone do operador Atualização de tabela](../../2014/database-engine/media/table-update-32x.gif "Ícone do operador Atualização de tabela")|`Table Update`|O `Table Update` operador físico atualiza linhas de entrada na tabela especificada no `Argument` coluna do plano de execução de consulta. O predicado SET: () determina o valor de cada coluna atualizada. Esses valores podem ser consultados na cláusula SET ou em outro lugar dentro desse operador assim como em outro lugar dessa consulta.|  
|![Ícone do operador Função com valor de tabela](../../2014/database-engine/media/table-valued-function-32x.gif "Ícone do operador Função com valor de tabela")|**Table-valued Function**|O operador **Table-valued Function** avalia uma função com valor de tabela ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) e armazena as linhas resultantes no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) . Quando os iteradores pai solicitam as linhas **Table-valued Function** retorna as linhas de `tempdb`.<br /><br /> As consultas com chamadas às funções com valor de tabela geram planos de consulta com o iterador de **Table-valued Function** . **Table-valued Function** pode ser avaliada com valores de parâmetros diferentes:<br /><br /> O**Leitor de XML da Função com valor de tabela** insere um BLOB XML como parâmetro e processa um conjunto de linhas representando os nós XML na ordem dos documentos XML. Outros parâmetros de entrada podem restringir os nós XML retornados a um subconjunto de documentos XML.<br /><br /> **Leitor de XML da Função com valor de tabela com filtro XPath** é um tipo especial de **Função com valor de tabela do Leitor de XML** que restringe a saída a nós XML que atendem a uma expressão XPath.<br /><br /> <br /><br /> **Table-valued Function** é um operador lógico e físico.|  
|![Ícone do operador Superior](../../2014/database-engine/media/top-32x.gif "Ícone do operador Superior")|**Top**|O operador **Top** verifica a entrada, retornando só o primeiro número ou porcentagem de linhas especificado, possivelmente com base em uma ordem de classificação. O `Argument` coluna pode conter uma lista das colunas cujas associações estão sendo verificadas. Em planos de atualização, o operador **Top** é usado para aplicar os limites de contagem de linhas. **Top** é um operador lógico e físico. **Top** é um operador lógico e físico.|  
|Nenhum|**Top N Sort**|**TOP N Sort** é semelhante de `Sort` iterador, exceto que somente as primeiras *N* linhas são necessárias, e não o todo conjunto de resultados. Para valores pequenos de *N*, o mecanismo de execução de consultas do [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] tenta executar toda a operação de classificação na memória. Para valores grandes de *N*, o mecanismo de execução de consultas recorre a um método de classificação mais genérico para o qual *N* não é um parâmetro.|  
|![Ícone do operador estendido (UDX)](../../2014/database-engine/media/udx-32x.gif "Ícone do operador estendido (UDX)")|`UDX`|Operadores estendidos (UDX) implementam uma de muitas operações XQuery e XPATH no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Todos os operadores UDX são classificados como operadores lógicos e físicos.<br /><br /> O operador estendido (UDX) `FOR XML` é usado para serializar o conjunto de linhas relacionais e insere em representação XML em uma única coluna BLOB em uma única linha de saída. É um operador de agregação XML sensível à ordenação.<br /><br /> O operador estendido (UDX) `XML SERIALIZER` é um operador de agregação XML sensível à ordenação. Ele insere linhas que representam nós XML ou escalares de XQuery em ordem de documento XML e produz um XML BLOB serializado em uma única coluna XML em uma única linha de saída.<br /><br /> O operador estendido (UDX) `XML FRAGMENT SERIALIZER`  é um tipo especial de `XML SERIALIZER` que é usado para processar linhas de entrada que representam fragmentos de XML que são inseridos na extensão de modificação de dados de inserção de XQuery.<br /><br /> O operador estendido (UDX) `XQUERY STRING` avalia o valor da cadeia de caracteres XQuery das linhas de entrada que representam nós de XML. É um operador de agregação de cadeia sensível à ordenação. Produz uma linha com colunas que representam o escalar de XQuery que contém o valor de cadeia de caracteres da entrada.<br /><br /> O operador estendido (UDX) `XQUERY LIST DECOMPOSER`é um operador de decomposição de lista de XQuery. Para cada linha de entrada que representa um nó de XML ele produz uma ou mais linhas, cada uma representando o escalar de Xquery, que contém um valor de elemento de lista caso a entrada seja do tipo lista de XSD.<br /><br /> O operador estendido (UDX) `XQUERY DATA` avalia a função XQuery fn:data() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:data()**.<br /><br /> O operador estendido (UDX) `XQUERY CONTAINS` avalia a função XQuery fn:contains() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:contains()**.<br /><br /> Operador estendido `UPDATE XML NODE` atualiza o nó XML no XQuery substitua a extensão de modificação de dados em de **Modify ()** método no tipo XML.|  
|Nenhum|**Union**|O operador **Union** verifica várias entradas, gerando a saída de cada linha examinada e removendo duplicatas. **Union** é um operador lógico.|  
|![Ícone do operador Atualizar (Mecanismo de Banco de Dados)](../../2014/database-engine/media/update-32x.gif "Ícone do operador Atualizar (Mecanismo de Banco de Dados)")|`Update`|O `Update` operador atualiza cada linha de sua entrada no objeto especificado no `Argument` coluna do plano de execução de consulta. `Update` é um operador lógico. O operador físico é `Table Update`, `Index Update` ou `Clustered Index Update`.|  
|![Ícone do elemento de linguagem While](../../2014/database-engine/media/while-32x.gif "Ícone do elemento de linguagem While")|`While`|O `While` operador implementa o [!INCLUDE[tsql](../includes/tsql-md.md)] loop while. `While` é um elemento de linguagem|  
|![Ícone do operador Spool de tabela](../../2014/database-engine/media/table-spool-32x.gif "Ícone do operador Spool de tabela")|`Window Spool`|O operador `Window Spool` expande cada linha no conjunto de linhas que representa a janela associada a ele. Em uma consulta, a cláusula OVER define a janela em um conjunto de resultados de consulta e uma função de janela, e depois computa um valor para cada linha na janela. `Window Spool` é um operador lógico e físico.|  
  
  
