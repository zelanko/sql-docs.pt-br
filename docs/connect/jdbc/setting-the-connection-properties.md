---
title: Configuração das propriedades de conexão | Microsoft Docs
ms.custom: ''
ms.date: 01/29/2019
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: f1b62700-f046-488d-bd6b-a5cd8fc345b7
author: MightyPen
ms.author: genemi
ms.openlocfilehash: c96c61ad94bb93e2c2c370452021cfb5b95efdba
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MTE75
ms.contentlocale: pt-BR
ms.lasthandoff: 07/15/2019
ms.locfileid: "68004459"
---
# <a name="setting-the-connection-properties"></a>Definindo as propriedades de conexão

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

As propriedades da cadeia de conexão podem ser especificadas de várias formas:

- Como as propriedades name=value na URL de conexão quando você conecta usando a classe DriverManager.
- As propriedades name = value no parâmetro *Properties* do método Connect na classe DriverManager.
- Como valores no método setter apropriado da fonte de dados do driver. Por exemplo:  
  
    ```java
    datasource.setServerName(value)  
    datasource.setDatabaseName(value)  
    ```  
  
## <a name="remarks"></a>Remarks

Os nomes de propriedade não diferenciam maiúsculas de minúsculas, e os nomes de propriedade duplicados são resolvidos na seguinte ordem:  
  
1. Argumentos de API (como usuário e senha)
2. Coleção de propriedades.  
3. Última instância na cadeia de conexão.
  
Além disso, são permitidos valores desconhecidos para os nomes de propriedade, e os valores não são validados pelo driver JDBC para diferenciação de maiúsculas de minúsculas.

São permitidos sinônimos, resolvidos na ordem, assim como nomes de propriedade duplicados.

A tabela a seguir lista todas as propriedades da cadeia de conexão disponíveis no momento para o driver JDBC.

| Propriedade<br/>Tipo<br/>Padrão | Descrição |
| :------------------------------ | :---------- |
| accessToken<br/><br/>Cadeia de caracteres<br/><br/>nulo | Use essa propriedade para se conectar a um banco de dados SQL usando um token de acesso. **accessToken** não pode ser definido usando a URL de conexão. |
| applicationIntent<br/><br/>Cadeia de caracteres<br/><br/>ReadWrite | Declara o tipo de carga de trabalho de aplicativo ao conectar-se a um servidor. <br/><br/>Os valores possíveis são **ReadOnly** e **ReadWrite**. <br/><br/>Para saber mais, confira [Suporte do JDBC Driver para Alta disponibilidade, Recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md). |
| applicationName<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O nome do aplicativo ou "[!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]" se nenhum nome tiver sido fornecido.<br/><br/>Usado para identificar o aplicativo específico em várias ferramentas de criação de perfil e de registro em log do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. |
| autenticação<br/><br/>Cadeia de caracteres<br/><br/>NotSpecified | A partir do Microsoft JDBC Driver 6,0 para SQL Server, essa propriedade opcional indica qual método de autenticação do SQL usar para conexão. Os valores possíveis são **ActiveDirectoryIntegrated**, **ActiveDirectoryPassword**, **ActiveDirectoryMSI**, **SQLPassword** e o padrão **não especificado**.<br/><br/> Use **ActiveDirectoryIntegrated** para se conectar a um banco de dados SQL usando a autenticação integrada do Windows.<br/><br/> Use **ActiveDirectoryPassword** para se conectar a um banco de dados SQL usando um nome e uma senha da entidade de segurança do Azure AD.<br/><br/> Use **ActiveDirectoryMSI** para se conectar a um banco de dados SQL de dentro de um recurso do Azure, por exemplo, uma máquina virtual do Azure, serviço de aplicativo ou aplicativo de funções usando a autenticação identidade de serviço gerenciada (MSI). <br><br>Os dois tipos de identidades gerenciadas com suporte pelo driver ao usar o modo de autenticação **ActiveDirectoryMSI** são: <br> 1. _Identidade gerenciada atribuída pelo sistema_: usada para adquirir **accessToken** por padrão. <br> 2. _Identidade gerenciada atribuída pelo usuário_: usada para adquirir **ACCESSTOKEN** se a ID do cliente de um identidade de serviço gerenciada (MSI) for especificada com a propriedade de conexão **msiClientId** .<br/><br/> Use **SQLPassword** para se conectar a um SQL Server usando as propriedades User e **password** do **nome**/de**usuário** .<br/><br/> Use **não especificado** se nenhum desses métodos de autenticação forem necessários.<br/><br/> **Importante:**  Se a autenticação for definida como ActiveDirectoryIntegrated, as duas bibliotecas a seguir precisarão ser instaladas: **SQLJDBC_AUTH. DLL** (disponível no pacote de driver JDBC) e Azure Active Directory biblioteca de autenticação para SQL Server (**ADALSQL. DLL**) está disponível em diferentes idiomas (para x86 e AMD64) do centro de download no [Microsoft Biblioteca de Autenticação do Active Directory para Microsoft SQL Server](https://www.microsoft.com/download/details.aspx?id=48742). O driver JDBC só dá suporte à versão **1.0.2028.318 e superior** para o ADALSQL. DLL.<br/><br/> **Observação:**  Quando a propriedade de autenticação é definida com qualquer valor diferente de **não especificado**, o driver por padrão usa a criptografia protocolo SSL (SSL).<br/><br/> Para obter informações sobre como configurar a autenticação [de Azure Active Directory, visite conectar-se ao banco de dados SQL usando a autenticação Azure Active Directory](https://azure.microsoft.com/documentation/articles/sql-database-aad-authentication/). |
| authenticationScheme<br/><br/>Cadeia de caracteres<br/><br/>NativeAuthentication | Indica que tipo de segurança integrada você deseja que o seu aplicativo use. Os valores possíveis são **JavaKerberos** e o **NativeAuthentication**padrão.<br/><br/> Ao usar **AuthenticationScheme = JavaKerberos**, você deve especificar o FQDN (nome de domínio totalmente qualificado) na  Propriedade **ServerName** ou **serverSpn** . Caso contrário, ocorrerá um erro (Servidor não encontrado no banco de dados de Kerberos).<br/><br/> Para obter mais informações sobre o uso do **authenticationScheme**, confira [Como usar a autenticação integrada do Kerberos para se conectar ao SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| cancelQueryTimeout<br/><br/>INT<br/><br/>-1 | A partir do Microsoft JDBC Driver 6,4 para SQL Server, essa propriedade pode ser usada para cancelar o **queryTimeout** definido na conexão. A execução da consulta é interrompida e não gera exceção se a conexão TCP com o SQL Server é descartada silenciosamente. Essa propriedade só será aplicável se ' queryTimeout ' também estiver definido na conexão. <br/><br/>O driver aguarda a quantidade total de **cancelQueryTimeout** + **queryTimeout** segundos, para descartar a conexão e fechar o canal. <br/><br/>O valor padrão para essa propriedade é-1 e o comportamento é aguardar indefinidamente. |
| columnEncryptionSetting<br/><br/>Cadeia de caracteres<br/>["Habilitado" &#124; "Desabilitado"]<br/><br/>Desabilitado | Definido como "Habilitado" para usar o início do recurso AE (Always Encrypted) com o Microsoft JDBC Driver 6.0 para o SQL Server. Quando AE está habilitado, o driver JDBC criptografa e descriptografa os dados confidenciais armazenados em colunas de banco de dados criptografado no SQL Server.<br/><br/> Para obter mais informações sobre **columnEncryptionSetting**, consulte [usando Always Encrypted com o driver JDBC](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md) para obter mais detalhes.<br/><br/> **Observação:**  Always Encrypted está disponível com o SQL Server 2016 ou versões posteriores. |
| databaseName,<br/>Banco de Dados<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O nome do banco de dados ao qual se conectar. <br/><br/>Se não for indicada, será estabelecida uma conexão com o banco de dados padrão. |
| disableStatementPooling<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | Sinalizador que indica se o pooling de instruções deve ser usado. |
| enablePrepareOnFirst...<br/>PreparedStatementCall<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | _enablePrepareOnFirstPreparedStatementCall_<br/><br/> Defina como "true" para habilitar a criação de identificador de instrução preparada <code>sp_prepexec</code> chamando na primeira execução da instrução preparada. <br/><br/>Defina como "false" para alterar a primeira execução de uma instrução preparada para chamar <code>sp_executesql</code> e não preparar uma instrução, depois que a segunda execução ocorrer, ela <code>sp_prepexec</code> chamaria a configuração de um identificador de instrução preparado. |
| encrypt<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Definido como "true" para especificar que o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] usa criptografia do protocolo SSL em todos os dados enviados entre o cliente e o servidor, caso este tenha um certificado instalado. O valor padrão é "falso".<br/><br/> A partir do Microsoft JDBC Driver 6,0 para SQL Server, há uma nova configuração de conexão "autenticação" que usa a criptografia SSL por padrão. <br/><br/>Para obter mais informações, veja a propriedade 'autenticação'. |
| failoverPartner<br/><br/>Cadeia de caracteres<br/><br/>nulo | O nome do servidor de failover usado em uma configuração de espelhamento de banco de dados. Essa propriedade é usada em uma falha de conexão inicial ao servidor principal; depois que você estabelecer a conexão inicial, essa propriedade será ignorada. Ele deve ser usado com a propriedade databaseName.<br/><br/> **Observação:** o driver não dá suporte à especificação do número da porta de instância do servidor para a instância do parceiro de failover como parte da propriedade failoverPartner na cadeia de conexão. No entanto, há suporte à especificação das propriedades serverName, instanceName e portNumber da instância do servidor principal e da propriedade failoverPartner da instância do parceiro de failover na mesma cadeia de conexão.<br/><br/> Se você especificar um Nome de Rede Virtual na propriedade de conexão **Server**, não poderá usar o espelhamento de bancos de dados. Para saber mais, confira [Suporte do JDBC Driver para Alta disponibilidade, Recuperação de desastres](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) |
| fips<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>"false" | Para a JVM habilitada para FIPS, essa propriedade deve ser **verdadeira**. |
| fipsProvider<br/><br/>Cadeia de caracteres<br/><br/>nulo | Provedor FIPS configurado na JVM. Por exemplo, BCFIPS ou SunPKCS11-NSS. Removido na versão 6.4.0-Veja os detalhes [aqui](https://github.com/Microsoft/mssql-jdbc/pull/460). |
| gsscredential<br/><br/>org.ietf.jgss.GSSCredential<br/><br/>nulo | A partir do Microsoft JDBC Driver 6,2 para SQL Server, as credenciais de usuário a serem usadas para a delegação restrita de Kerberos podem ser passadas nessa propriedade. <br/><br/>Isso deve ser usado com **IntegratedSecurity** como **true** e **JavaKerberos** **AuthenticationScheme**. |
| hostNameInCertificate<br/><br/>Cadeia de caracteres<br/><br/>nulo | O nome do host a ser usado durante a validação do certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> Se a propriedade hostNameInCertificate não for especificada ou estiver definida como nula, o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] usará o valor da propriedade **serverName** na URL de conexão como o nome do host para validar o certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> **Observação:**  Essa propriedade é usada em combinação com as propriedades de**autenticação** de **criptografia**/e a propriedade **TrustServerCertificate** . Essa propriedade afeta a validação do certificado, se e somente se a conexão usar a criptografia protocolo SSL (SSL) e o **TrustServerCertificate** estiver definido como "false". Verifique se o valor passado para **hostNameInCertificate** corresponde exatamente ao CN (Nome Comum) ou ao nome DNS no SAN (Nome Alternativo da Entidade) no certificado do servidor para que uma conexão SSL tenha êxito. Para obter mais informações, consulte [noções básicas sobre o suporte a SSL](../../connect/jdbc/understanding-ssl-support.md). |
| NOMEDAINSTÂNCIA<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O nome da instância do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] à qual se conectar. Quando ela não for especificada, uma conexão será estabelecida com a instância padrão. Para o caso em que instanceName e a porta forem especificadas, veja as observações para a porta.<br/><br/> Se você especificar um nome de rede virtual na propriedade de conexão **Server**, não poderá usar a propriedade de conexão **instanceName**. Confira [Suporte do JDBC Driver para alta disponibilidade, recuperação de desastre](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para saber mais. |
| integratedSecurity<br/><br/>booleano<br/>["true"&#124;"false"]<br/><br/>false | Defina como "true" para indicar que as credenciais do Windows são [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] usadas pelo em sistemas operacionais Windows. Se "true", o driver JDBC procurará no cache da credencial do computador local as credenciais que já foram fornecidas no computador ou no logon da rede.<br/><br/> Defina como "true" (com **AuthenticationScheme = JavaKerberos**) para indicar que as credenciais Kerberos são usadas pelo [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Para obter mais informações sobre a autenticação do Kerberos, confira [Como usar a autenticação integrada do Kerberos para se conectar ao SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). <br/><br/> Se "false", o nome de usuário e a senha deverão ser fornecidos. |
| jaasConfigurationName<br/><br/>Cadeia de caracteres<br/><br/>SQLJDBCDriver | A partir do Microsoft JDBC Driver 6,2 para SQL Server, cada conexão com SQL Server pode ter seu próprio arquivo de configuração de logon JAAS para estabelecer a conexão Kerberos. O nome do arquivo de configuração de logon pode ser passado por essa propriedade. <br/> Por padrão, o driver define `useDefaultCcache = true` a propriedade para IBM JVMs `useTicketCache = true` e para outros JVMs. |
| keyStoreAuthentication<br/><br/>Cadeia de caracteres<br/><br/>nulo | A partir do Microsoft JDBC Driver 6,0 para SQL Server, essa propriedade identifica qual repositório de chaves deve ser configurado diretamente para a conexão com Always Encrypted e determina um mecanismo de autenticação usado para autenticação no repositório de chaves. O Microsoft JDBC Driver 6,0 para SQL Server dá suporte à configuração do repositório de chaves Java diretamente usando essa propriedade para a qual você precisa definir "**keyStoreAuthentication = JavaKeyStorePassword**". Observe que, para usar essa propriedade, você também precisa definir as propriedades **keyStoreLocation** e **KeyStoreSecret** para o repositório de chaves Java. <br/><br/>Para obter mais informações, visite [Como usar Always Encrypted com o driver JDBC](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| keyStoreLocation<br/><br/>Cadeia de caracteres<br/><br/>nulo | Quando **keyStoreAuthentication = JavaKeyStorePassword**, a propriedade **keyStoreLocation** identifica o caminho para o arquivo de repositório de chaves Java que armazena a chave mestra de coluna a ser usada com Always Encrypted dados. Observe que o caminho deve incluir o nome de arquivo do repositório de chaves.<br/><br/>Para obter mais informações, visite [Como usar Always Encrypted com o driver JDBC](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| keyStoreSecret<br/><br/>Cadeia de caracteres<br/><br/>nulo | Quando **keyStoreAuthentication = JavaKeyStorePassword**, a propriedade **keyStoreSecret** identifica a senha a ser usada para o repositório de chaves, bem como para a chave. Observe que, para usar o repositório de chaves Java, o keystore e a senha de chave devem ser iguais.<br/><br/>Para obter mais informações, visite [Como usar Always Encrypted com o driver JDBC](https://msdn.microsoft.com/library/mt591987%28v=sql.110%29.aspx?f=255&MSPPError=-2147217396). |
| lastUpdateCount<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | Um valor "true" só retorna a contagem de atualização mais recente de uma instrução SQL passada para o servidor, podendo ser usado em instruções SELECT, INSERT ou DELETE para ignorar contagens de atualização adicionais causadas por gatilhos de servidor. A definição dessa propriedade como "false" faz com que todas as contagens de atualização sejam retornadas, inclusive as retornadas por gatilhos de servidor.<br/><br/> **Observação:** essa propriedade só se aplica quando usada com os métodos [executeUpdate](../../connect/jdbc/reference/executeupdate-method-sqlserverstatement.md). Todos os outros métodos execute retornam todos os resultados e as contagens de atualização. Essa propriedade só afeta contagens de atualização retornadas por gatilhos de servidor. Ela não afeta conjuntos de resultados ou erros resultantes de parte da execução do gatilho. |
| lockTimeout<br/><br/>INT<br/><br/>-1 | O número de milissegundos para aguardar antes do banco de dados informar um tempo limite de bloqueio. O comportamento padrão é aguardar indefinidamente. Se for especificado, esse valor será o padrão para todas as instruções na conexão. Observe que **Statement. SetQueryTimeout ()** pode ser usado para definir o tempo limite para instruções específicas. O valor pode ser 0, que especifica a ausência de espera. |
| loginTimeout<br/><br/>INT<br/>[0..65535]<br/><br/>15 | O número de segundos que o driver deve aguardar antes que o tempo limite de uma conexão com falha seja alcançado. Um valor igual a zero indica que o tempo limite é o padrão do sistema, especificado como 15 segundos por padrão. Um valor diferente de zero é o número de segundos que o driver deve aguardar antes do tempo limite de uma conexão com falha.<br/><br/> Se você especificar um nome de rede virtual na propriedade de conexão **Server**, especifique um valor de tempo limite de três minutos ou mais para dar tempo suficiente para a conexão de failover ter êxito. Confira [Suporte do JDBC Driver para alta disponibilidade, recuperação de desastre](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para saber mais. |
| msiClientId<br/><br/>Cadeia de caracteres<br/><br/>nulo | A ID do cliente do Identidade de Serviço Gerenciada (MSI) a ser usado para adquirir **accessToken** ao estabelecer uma conexão com o modo de autenticação **ActiveDirectoryMSI** .|
| multiSubnetFailover<br/><br/>Booliano<br/><br/>false | Sempre especifique **multiSubnetFailover=True** ao se conectar ao ouvinte de um grupo de disponibilidade do [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] ou a uma instância de cluster de failover do [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]. **multiSubnetFailover=true** configura o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] para fornecer mais rapidez na detecção do servidor ativo (atualmente) e na conexão a ele. Os valores possíveis são true e false. Confira [Suporte do JDBC Driver para alta disponibilidade, recuperação de desastre](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para saber mais.<br/><br/> Você pode acessar de forma programática a propriedade de conexão **multiSubnetFailover** com [getPropertyInfo](../../connect/jdbc/reference/getpropertyinfo-method-sqlserverdriver.md), [getMultiSubnetFailover](../../connect/jdbc/reference/getmultisubnetfailover-method-sqlserverdatasource.md) e [setMultiSubnetFailover](../../connect/jdbc/reference/setmultisubnetfailover-method-sqlserverdatasource.md).<br/><br/> **Observação:**  A partir do Microsoft JDBC Driver 6,0 para SQL Server, não é mais necessário definir **multiSubnetFailover** como "true" ao se conectar a um ouvinte de grupo de disponibilidade. Uma nova propriedade, **transparentNetworkIPResolution**, que está habilitada por padrão, fornece a detecção e a conexão com o servidor ativo (atualmente). |
| packetSize<br/><br/>INT<br/>[-1 &#124; 0 &#124; 512..32767]<br/><br/>8000 | O tamanho do pacote de rede usado para se comunicar com o SQL Server, especificado em bytes. Um valor igual a -1 indica o uso do tamanho de pacote padrão do servidor. Um valor igual a 0 indica o uso do valor máximo, 32767. Se essa propriedade for definida como um valor fora do intervalo aceitável, ocorrerá uma exceção.<br/><br/> **Importante:** não recomendamos o uso da propriedade packetSize quando a criptografia estiver habilitada (encrypt=true). Do contrário, o driver pode acionar um erro na conexão. Para obter mais informações, veja o método [setPacketSize](../../connect/jdbc/reference/setpacketsize-method-sqlserverdatasource.md) da classe [SQLServerDataSource](../../connect/jdbc/reference/sqlserverdatasource-class.md). |
| password<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | A senha do banco de dados, no caso de conexão com o usuário e a senha do SQL.<br/>Para a conexão Kerberos com o nome de entidade de segurança e a senha, essa propriedade é definida como senha de entidade de segurança Kerberos. |
| portNumber,<br/>port<br/><br/>INT<br/>[0..65535]<br/><br/>1433 | A porta em que [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] está escutando. Se o número da porta for especificado na cadeia de conexão, nenhuma solicitação para SQLbrowser será feita. Quando a porta e instanceName forem especificadas, a conexão será estabelecida com a porta especificada. No entanto, **instanceName** será validado e um erro será lançado se não corresponder à porta.<br/><br/> **Importante:** recomendamos que o número da porta seja especificado sempre, porque isso é mais seguro do que o uso de SQLbrowser. |
| queryTimeout<br/><br/>INT<br/><br/>-1 | O número de segundos a aguardar antes de um tempo limite ter ocorrido em uma consulta. O valor padrão é-1, o que significa tempo limite infinito. Definir isso como 0 também implica em aguardar indefinidamente. |
| responseBuffering<br/><br/>Cadeia de caracteres<br/>["full" &#124; "adaptive"]<br/><br/>adaptive | Se essa propriedade for definida como "adaptive", o mínimo de dados possíveis será armazenado em buffer quando necessário. O modo padrão é "adaptável".<br/><br/> Quando essa propriedade for definida como "full", todo o conjunto de resultados será lido no servidor quando uma instrução for executada.<br/><br/> **Observação:** depois de atualizar o JDBC Driver da versão 1.2, o comportamento de armazenamento em buffer padrão será "adaptável". Se o aplicativo nunca tiver definido a propriedade "responseBuffering" e você quiser manter o comportamento padrão da versão 1.2 no aplicativo, será preciso definir a propriedade responseBufferring como "full" nas propriedades da conexão ou usando o método [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md) do objeto [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md). |
| selectMethod<br/><br/>Cadeia de caracteres<br/>["direct" &#124; "cursor"]<br/><br/>direct | Se essa propriedade for definida como "cursor", um banco de dados será criado para cada consulta criada na conexão dos cursores **TYPE_FORWARD_ONLY** e **CONCUR_READ_ONLY**. Essa propriedade só costuma ser obrigatória caso o aplicativo gere conjuntos de resultados grandes que não possam estar inteiramente contidos na memória do cliente. Quando essa propriedade estiver definida como "cursor", apenas um número limitado de linhas do conjunto de resultados será mantido na memória do cliente. <br/><br/>O comportamento padrão é que todas as linhas do conjunto de resultados sejam mantidas na memória do cliente. Esse comportamento fornece o melhor desempenho quando o aplicativo processa todas as linhas. |
| sendStringParameters...<br/>AsUnicode<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | *sendStringParametersAsUnicode*<br/><br/>Se a propriedade **sendStringParametersAsUnicode** for definida como "true", os parâmetros String serão enviados para o servidor no formato Unicode.<br/><br/> Se a propriedade **sendStringParametersAsUnicode** for definida como "false", os parâmetros da cadeia de caracteres serão enviados para o servidor no formato não Unicode, como ASCII/MBCS, em vez de Unicode.<br/><br/> O valor padrão da propriedade **sendStringParametersAsUnicode** é "true".<br/><br/> **Observação:** a propriedade **sendStringParametersAsUnicode** é verificada apenas durante o envio de um valor de parâmetro com os tipos JDBC **CHAR**, **VARCHAR** ou **LONGVARCHAR**. Os novos métodos de caractere nacional JDBC 4.0, como os métodos setNString, setNCharacterStream e setNClob das classes [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) e [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) sempre enviam os valores de parâmetro para o servidor em Unicode, independentemente da configuração dessa propriedade.<br/><br/> Para obter o desempenho ideal com os tipos de dados **CHAR**, **VARCHAR** e **LONGVARCHAR**, um aplicativo deve definir a propriedade **sendStringParametersAsUnicode** como "false" e usar os métodos de caractere não nacional setString, setCharacterStream e setClob das classes [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) e [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md).<br/><br/> Quando o aplicativo define a propriedade **sendStringParametersAsUnicode** como "false" e usa um método de caractere não nacional para acessar tipos de dados Unicode no lado do servidor (como **nchar**, **nvarchar** e **ntext**), alguns dados podem ser perdidos caso a ordenação do banco de dados não dê suporte aos caracteres nos parâmetros da cadeia de caracteres passados pelo método de caractere não nacional.<br/><br/> Observe que um aplicativo deve usar os métodos de caractere nacional setNString, setNCharacterStream e setNClob das classes [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) e [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) para o **nchar**, **nvarchar**, e tipos de dados **LONGNVARCHAR** JDBC. |
| sendTimeAsDatetime<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | Essa propriedade foi adicionada ao [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] JDBC Driver 3.0.<br/><br/> Defina como "true" para enviar valores java. Sql. time ao servidor como valores [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] de **data e hora** . <br/>Defina como "false" para enviar valores java. Sql. time ao servidor como [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] valores de **hora** .<br/><br/> O valor padrão para essa propriedade é "true" no momento e pode ser alterado em uma versão futura.<br/><br/> Para obter mais informações sobre como [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] o configura os valores de Java. Sql. time antes de enviá-los ao servidor, consulte Configurando [como os valores de Java. Sql. time são enviados ao servidor](../../connect/jdbc/configuring-how-java-sql-time-values-are-sent-to-the-server.md). |
| serverName,<br/>servidor<br/><br/>Cadeia de caracteres<br/><br/>nulo | O computador no qual o [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] está em execução.<br/><br/> Você também pode especificar o Nome de Rede Virtual de um grupo de disponibilidade [!INCLUDE[ssHADR](../../includes/sshadr_md.md)]. Confira [Suporte do JDBC Driver para alta disponibilidade, recuperação de desastre](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md) para saber mais. |
| serverNameAsACE<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Começando com o Microsoft JDBC Driver 6.0 for SQL Server, definido como “true” para indicar que o driver deve traduzir o nome do servidor Unicode para a codificação compatível ASCII (Punycode) para a conexão. Se essa configuração for “false”, o driver se conecta usando o nome do servidor, conforme fornecido pelo usuário.<br/><br/> Consulte [recursos internacionais do driver JDBC](../../connect/jdbc/international-features-of-the-jdbc-driver.md) para obter mais detalhes. |
| serverPreparedStatement...<br/>DiscardThreshold<br/><br/>Integer<br/><br/>10 | *serverPreparedStatementDiscardThreshold*<br/><br/>A partir do JDBC Driver 6,2 para SQL Server, essa propriedade pode ser usada para controlar quantas ações de descarte de instrução<code>sp_unprepare</code>preparadas pendentes () podem estar pendentes por conexão antes que uma chamada para limpar os identificadores pendentes no servidor seja executada . <br/><br/> Se essa propriedade for definida como &lt;= 1, as ações despreparar serão executadas imediatamente no fechamento da instrução preparada. Se estiver definido como &gt;1, essas chamadas serão agrupadas em lote para evitar a sobrecarga de chamar sp_unprepare com muita frequência. |
| serverSpn<br/><br/>Cadeia de caracteres<br/><br/>nulo | A partir do Microsoft JDBC Driver 4.2 para SQL Server, essa propriedade opcional pode ser usada para especificar o Nome da Entidade de Serviço (SPN) para uma conexão Kerberos Java.  Ele é usado em conjunto com **AuthenticationScheme**.<br/><br/> Para especificar a SPN, ela pode estar na forma de: "MSSQLSvc/fqdn:port@REALM" – em que fqdn é o nome de domínio totalmente qualificado, porta é o número da porta e REALM é o realm de Kerberos do SQL Server em letras maiúsculas.<br/><br/> Observação: o @REALM será opcional se o realm padrão do cliente (conforme especificado na configuração do Kerberos) for o mesmo que o realm do Kerberos para o SQL Server.<br/><br/> Para obter mais informações sobre o uso do **serverSpn** com o Java Kerberos, confira [Usando a autenticação integrada Kerberos para conectar-se ao SQL Server](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md). |
| statementPooling...<br/>CacheSize<br/><br/>INT<br/><br/>0 | *statementPoolingCacheSize*<br/><br/>A partir do JDBC Driver 6,4 para SQL Server, essa propriedade pode ser usada para habilitar o cache de identificador de instrução preparado no driver. <br/><br/>Essa propriedade define o tamanho do cache para o pooling de instruções. <br/><br/>Essa propriedade só pode ser usada em conjunto com a propriedade de conexão **disableStatementPooling** que deve ser definida como "false". Definir **disableStatementPooling** como "true" ou **statementPoolingCacheSize** como 0 desabilita o cache do identificador de instrução preparado.|
| socketTimeout<br/><br/>INT<br/><br/>0 | O número de milissegundos de espera antes que um tempo limite seja atingido em um soquete de leitura ou aceitação. O valor padrão é 0, o que significa tempo limite infinito. |
| sslProtocol<br/><br/>Cadeia de caracteres<br/><br/>TLS | A partir do JDBC Driver 6,4 para SQL Server, essa propriedade pode ser usada para especificar o protocolo TLS a ser considerado durante a conexão segura. <br/>Os valores possíveis são: **TLS**, **TLSv1**, **TLSv1.1** e **TLSv1.2**. <br/><br/>Para obter mais informações, consulte [SslProtocol](https://github.com/Microsoft/mssql-jdbc/wiki/SSLProtocol). |
| transparentNetwork...<br/>IPResolution<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>true | *transparentNetworkIPResolution*<br/><br/>A partir do Microsoft JDBC Driver 6,0 para SQL Server, essa propriedade fornece detecção mais rápida e conexão com o servidor ativo (atualmente). Os valores possíveis são "true" e "false", em que "true" é o valor padrão.<br/><br/> Antes do Microsoft JDBC Driver 6,0 para SQL Server, um aplicativo tinha que definir a cadeia de conexão para incluir "multiSubnetFailover = true" para indicar que estava se conectando a um grupo de disponibilidade AlwaysOn. Sem definir a palavra-chave de conexão **multiSubnetFailover** como "true", um aplicativo pode enfrentar um tempo limite ao se conectar a um Grupo de disponibilidade AlwaysOn. A partir do Microsoft JDBC Driver 6,0 para SQL Server, um aplicativo não precisará definir multiSubnetFailover como mais verdadeiro. <br/><br/>**Observação:** Quando transparentNetworkIPResolution = true, a primeira tentativa de conexão usa 500 MS como o tempo limite. Todas as tentativas subsequentes usam a mesma lógica de tempo limite usada pela propriedade multiSubnetFailover. |
| trustManagerClass<br/><br/>Cadeia de caracteres<br/><br/>nulo | O nome de classe totalmente qualificado de uma <code>javax.net.ssl.TrustManager</code> implementação personalizada. |
| TrustManager...<br/>ConstructorArg<br/><br/>Cadeia de caracteres<br/><br/>nulo | *trustManagerConstructorArg*<br/><br/>Um argumento opcional para passar para o construtor de TrustManager. Se trustManagerClass for especificado e uma conexão criptografada for solicitada, o TrustManager personalizado será usado em vez do TrustManager baseado no repositório de chaves JVM do sistema padrão. |
| trustServerCertificate<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Defina como "true" para especificar que o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] não valida o certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].<br/><br/> Se "true", o certificado SSL do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] será considerado confiável automaticamente quando a camada de comunicação for criptografada com SSL.<br/><br/> Se "false", o [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] validará o certificado SSL do servidor. Se houver falha na validação do certificado do servidor, o driver lançará um erro e encerrará a conexão. O valor padrão é "falso". Verifique se o valor passado para **serverName** corresponde exatamente ao CN (Nome Comum) ou ao nome DNS no Nome Alternativo da Entidade no certificado do servidor para que uma conexão SSL tenha êxito. Para obter mais informações, consulte [noções básicas sobre o suporte a SSL](../../connect/jdbc/understanding-ssl-support.md).<br/><br/> **Observação:** Essa propriedade é usada em combinação com as propriedades de**autenticação** de **criptografia**/. Essa propriedade só afetará a validação do certificado SSL do servidor se e somente se a conexão usar a criptografia SSL. |
| trustStore<br/><br/>Cadeia de caracteres<br/><br/>nulo | O caminho (inclusive o nome de arquivo) para o arquivo trustStore do certificado. O arquivo trustStore contém a lista de certificados nos quais o cliente confia.<br/><br/> Quando essa propriedade não for especificada ou for definida como nula, o driver contará com as regras de pesquisa de fábrica do gerenciador de confiança para determinar que repositório de certificados usar.<br/><br/> **O padrão SunX509 TrustManagerFactory tenta localizar o material confiável na seguinte ordem de pesquisa:**<br/><br/> Um arquivo especificado pela propriedade do sistema JVM (Máquina Virtual Java) "javax.net.ssl.trustStore".<br/><br/> Arquivo "&lt;java-home&gt;/lib/security/jssecacerts".<br/><br/> Arquivo "&lt;java-home&gt;/lib/security/cacerts".<br/><br/> <br/><br/> Para obter mais informações, consulte a documentação do SUNX509 TrustManager Interface no site da Sun Microsystems.<br/><br/> **Observação:** Essa propriedade afeta somente a pesquisa de trustStore de certificado, se e somente se a conexão usar a criptografia SSL e a propriedade **TrustServerCertificate** for definida como "false". |
| trustStorePassword<br/><br/>Cadeia de caracteres<br/><br/>nulo | A senha usada para verificar a integridade dos dados de trustStore.<br/><br/> Se a propriedade trustStore for definida, mas a propriedade trustStorePassword não for definida, a integridade de trustStore não será verificada.<br/><br/> Quando as propriedades trustStore e trustStorePassword não forem especificadas, o driver usará as propriedades do sistema JVM, "javax.net.ssl.trustStore" e "javax.net.ssl.trustStorePassword". Se a propriedade do sistema "javax.net.ssl.trustStorePassword" não for especificada, a integridade de trustStore não será verificada.<br/><br/> Se a propriedade trustStore não estiver definida, mas a propriedade trustStorePassword estiver, o driver JDBC usará o arquivo especificado por "javax.net.ssl.trustStore" como um repositório confiável e a integridade dele será verificada com trustStorePassword. Isso pode ser necessário quando o aplicativo cliente não quiser armazenar a senha na propriedade do sistema JVM.<br/><br/> **Observação:**  A propriedade trustStorePassword afeta somente a pesquisa de trustStore de certificado, se e somente se a conexão usar a conexão SSL e a propriedade **TrustServerCertificate** estiver definida como "false". |
| trustStoreType<br/><br/>Cadeia de caracteres<br/><br/>JKS | Defina essa propriedade para especificar o tipo de repositório de confiança a ser usado para o modo FIPS. <br/><br/>Os valores possíveis são **PKCS12** ou type definido pelo provedor FIPS. |
| useBulkCopyFor...<br/>BatchInsert<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | _useBulkCopyForBatchInsert_<br/><br/> A partir do Microsoft JDBC Driver 7,0 para SQL Server, essa propriedade de conexão pode ser habilitada para fazer uso da API de cópia em massa ao <code>java.sql.PreparedStatement</code> executar operações de inserção em lote usando para aprimoramento de desempenho. <br/><br/>Este recurso só funcionará quando o servidor de destino for do tipo **Azure data warehouse**. Ele é desabilitado por padrão, defina essa propriedade como "true" para habilitar esse recurso. <br/></br> **Observação importante:** Esse recurso dá suporte apenas a consultas INSERT com parâmetros totalmente. Se as consultas de inserção forem combinadas por outras consultas SQL ou contiverem dados em valores, a execução retornará à operação de inserção de lote básica. <br/><br/> Para obter mais informações sobre como usar essa propriedade, consulte [usando a API de cópia em massa para a operação de inserção em lote](use-bulk-copy-api-batch-insert-operation.md)|
| userName,<br/>usuário<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>nulo | O usuário do banco de dados, no caso de conexão com o usuário e a senha do SQL.<br/><br/>Para a conexão Kerberos com o nome de entidade de segurança e a senha, essa propriedade é definida como nome da entidade de segurança Kerberos. |
| workstationID<br/><br/>Cadeia de caracteres<br/>[&lt;=128 char]<br/><br/>&lt;cadeia de caracteres vazia&gt; | A ID da estação de trabalho. Usado para identificar a estação de trabalho específica em várias ferramentas de criação de perfil e de registro em log do [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. <br/><br/>Se nenhum for especificado, a &lt;cadeia de caracteres vazia&gt; será usada. |
| xopenStates<br/><br/>booleano<br/>["true" &#124; "false"]<br/><br/>false | Defina como "true" para especificar que o driver retorna códigos de estado compatíveis com XOPEN em exceções. <br/><br/>O padrão é retornar códigos de estado SQL 99. |
| &nbsp; | &nbsp; |

> [!NOTE]  
> O [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] recebe os valores padrão do servidor para propriedades de conexão, exceto para ANSI_DEFAULTS e IMPLICIT_TRANSACTIONS. O [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] define automaticamente ANSI_DEFAULTS como ON e IMPLICIT_TRANSACTIONS como OFF.

> [!Important]
> Se a autenticação for definida como ActiveDirectoryPassword, a biblioteca a seguir precisará ser incluída no classpath: [Azure-ActiveDirectory-library-for-Java](https://github.com/AzureAD/azure-activedirectory-library-for-java). Ele pode ser encontrado no [repositório do Maven](https://mvnrepository.com/artifact/com.microsoft.azure/adal4j). A maneira mais simples de baixar a biblioteca e suas dependências é usar o Maven: 
> 1. Primeiro, instale o Maven no seu sistema 
> 2. Ir para a [página do GitHub](https://github.com/Microsoft/mssql-jdbc) do driver
> 3. Baixar o arquivo pom. xml
> 4. Execute o seguinte comando do Maven para baixar a biblioteca e suas dependências:`mvn dependency:copy-dependencies`

## <a name="see-also"></a>Consulte Também

[Conectando ao SQL Server com o JDBC Driver](../../connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver.md)  
[Modo FIPS](../../connect/jdbc/fips-mode.md)
