---
title: Referência de operadores físicos e lógicos de plano de execução | Microsoft Docs
ms.custom: ''
ms.date: 10/12/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
- sql13.swb.showplan.foreignkeyreferencescheck
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 46578b4795bc02b0d426564b357dea580665ceeb
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 07/15/2019
ms.locfileid: "68048846"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referência de operadores físicos e lógicos de plano de execução
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
  Os operadores descrevem como o [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executa uma consulta ou uma instrução DML (Linguagem de Manipulação de Dados). O otimizador de consultas usa os operadores para criar um plano de consulta a fim de criar o resultado especificado na consulta ou para executar a operação especificada na instrução DML. O plano de consulta é uma árvore que consiste em operadores físicos. Você pode exibir o plano de consulta usando as instruções SET SHOWPLAN, as opções de plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou as classes de evento do Plano de Execução do SQL Server Profiler.  
  
 Os operadores são classificados como lógicos e físicos.  
  
 **Operadores lógicos**  
 Os operadores lógicos descrevem a operação algébrica relacional usada para processar uma instrução. Em outras palavras, operadores lógicos descrevem conceitualmente qual operação precisa ser executada.  
  
 **Operadores físicos**  
 Os operadores físicos implementam a operação descrita pelos operadores lógicos. Cada operador físico é um objeto ou uma rotina que executa uma operação. Por exemplo, alguns operadores físicos acessam colunas ou linhas de uma tabela, índice ou exibição. Outros operadores físicos executam outras operações como cálculos, agregações, verificações da integridade de dados ou junções. Os operadores físicos possuem custos associados.  
  
 Os operadores físicos iniciam, coletam dados e fecham. Especificamente, o operador físico pode responder às três chamadas de método abaixo:  
  
-   **Init()** : o método **Init()** faz com que um operador físico se inicialize e define quaisquer estruturas de dados necessárias. O operador físico pode receber muitas chamadas **Init()** ; entretanto, um operador físico costuma receber somente uma.  
  
-   **GetNext()** : o método **GetNext()** faz um operador físico obter a primeira linha de dados ou a subsequente. O operador físico pode receber zero ou muitas chamadas **GetNext()** .  
  
-   **Close()** : o método **Close()** faz um operador físico executar algumas operações de limpeza total e se desligar. Um operador físico só recebe uma chamada **Close()** .  
  
O método **GetNext()** retorna uma linha de dados e o número de vezes em que é chamado aparece como **ActualRows** na saída do Plano de Execução que é produzida usando as opções SET STATISTICS PROFILE ON ou SET STATISTICS XML ON. Para obter mais informações sobre essas opções SET, veja [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-profile-transact-sql.md) e [SET STATISTICS XML &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
Os contadores **ActualRebinds** e **ActualRewinds** exibidos na saída do Plano de Execução referem-se ao número de vezes que o método **Init()** é chamado. A menos que um operador esteja no lado interno de uma junção de loop, **ActualRebinds** será igual a um e **ActualRewinds** será igual a zero. Se um operador estiver no lado interno de uma junção de loop, a soma do número de reassociações e retrocessos deve ser igual ao número de linhas processadas no lado externo da junção. Uma reassociação significa que um ou mais dos parâmetros correlatos da junção se alterou e o lado interno deve ser reavaliado. Um retrocesso significa que nenhum dos parâmetros correlatos se alterou e o conjunto de resultados interno anterior pode ser usado novamente.  
  
**ActualRebinds** e **ActualRewinds** estão presentes na saída do Plano de Execução XML produzida usando a opção SET STATISTICS XML ON. Eles só são populados para os operadores **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**e **Table-valued Function** . **ActualRebinds** e **ActualRewinds** também podem ser populados para os operadores **Assert** e **Filter** quando o atributo **StartupExpression** é definido como TRUE.  
  
Quando **ActualRebinds** e **ActualRewinds** estiverem presentes em um Plano de Execução XML, serão comparáveis a **EstimateRebinds** e **EstimateRewinds**. Quando estiverem ausentes, o número estimado de linhas (**EstimateRows**) será comparável ao número de linhas real (**ActualRows**). Observe que a saída gráfica real do Plano de Execução exibe zeros para reassociações e retrocessos reais quando eles estão ausentes.  
  
Um contador relacionado, **ActualEndOfScans**, só está disponível quando a saída do Plano de Execução é produzida usando a opção SET STATISTICS XML ON. Sempre que um operador físico chega ao término de seu fluxo de dados, esse contador é incrementado em um. Um operador físico pode chegar ao término de seu fluxo de dados zero, uma ou mais vezes. Como com as reassociações e os retrocessos, o número de término de exames só poderá ser superior a um se o operador estiver no lado interno de uma junção de loop. O número de término de exames deveria ser inferior ou igual à soma do número de reassociações e retrocessos.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapeando operadores físicos e lógicos  
 O otimizador de consulta cria um plano de consulta como uma árvore que consiste em operadores lógicos. Depois de criar o plano, o otimizador de consulta escolhe o operador físico mais eficiente para cada operador lógico. O otimizador de consulta usa uma abordagem baseada em custos para determinar qual operador físico implementará um operador lógico.  
  
 Normalmente, uma operação lógica pode ser implementada por diversos operadores físicos. Em alguns casos raros, porém, um operador físico também pode implementar diversas operações lógicas.  
  
## <a name="operator-descriptions"></a>Descrições dos operadores  
 Esta seção contém descrições dos operadores lógicos e físicos.  
  
|Ícone do plano de execução gráfica|Operador de plano de execução|Descrição|  
|-----------------------------------|-----------------------|-----------------|  
|![Ícone do operador de Junção Adaptável](../relational-databases/media/AdaptiveJoin.gif "Ícone do operador de Junção Adaptável")|**Junção Adaptável**|O operador de **Junção Adaptável** habilita que as opções de método de junção hash ou de junção de loop aninhado sejam adiadas até após a verificação da primeira entrada. | 
|None|**Agregado**|O operador **Aggregate** calcula uma expressão que contém MIN, MAX, SUM, COUNT ou AVG. O operador **Aggregate** pode ser um operador lógico ou um operador físico.| 
|![Ícone do operador de expressão aritmética](../relational-databases/media/arithmetic-expression-32x-2.gif "Ícone do operador de expressão aritmética")|**Arithmetic Expression**|O operador **Arithmetic Expression** computa um valor novo de valores existentes em uma linha. **Expressão Aritmética** não é usada no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|None|**Async Concat**|O operador **Async Concat** só é usado em consultas remotas (consultas distribuídas). Ele tem *n* filhos e um nó pai. Normalmente, alguns dos filhos são computadores remotos que participam de uma consulta distribuída. O **Async Concat** emite `open()` chamadas simultaneamente a todos os filhos e aplica um bitmap para cada filho. Para cada bit que é um 1, **Async Concat** envia linhas de saída para o nó pai sob demanda.| 
|![Ícone do operador Assert](../relational-databases/media/assert-32x.gif "Ícone do operador Assert")|**Assert**|O operador **Assert** verifica uma condição. Por exemplo, ele valida integridade referencial ou assegura que uma subconsulta escalar retorne uma linha. Para cada linha de entrada, o operador **Assert** avalia a expressão na coluna **Argumento** do plano de execução. Se essa expressão for avaliada como NULL, a linha será passada pelo operador **Assert** e a execução de consulta continuará. Se essa expressão for avaliada como um valor não nulo, será gerado um erro apropriado. O operador **Assert** é um operador físico.| 
|![Ícone do elemento Atribuir linguagem](../relational-databases/media/assign-32.gif "Ícone do elemento Atribuir linguagem")|**Assign**|O operador **Assign** atribui o valor de uma expressão ou constante a um variável. **Assign** é um elemento de linguagem.| 
|![Ícone do operador de bitmap](../relational-databases/media/bitmap-32x.gif "Ícone do operador de bitmap")|**Bitmap Create**|O operador **Bitmap Create** aparece na saída do plano de execução onde os bitmaps são criados. **Bitmap Create** é um operador lógico.| 
|![Ícone do operador de bitmap](../relational-databases/media/bitmap-32x.gif "Ícone do operador de bitmap")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] usa o operador **Bitmap** para implementar filtro de bitmap em planos de consulta paralelos. O filtro de bitmap acelera a execução de consulta eliminando linhas com valores de chave que não podem produzir nenhum relatório de junção antes de transmitir as linhas por outro operador como o operador **Parallelism** . Um filtro de bitmap usa uma representação compacta de um conjunto de valores de uma tabela em uma parte da árvore de operador de uma segunda tabela em outra parte da árvore. Com a remoção de linhas desnecessárias previamente na consulta, os operadores subsequentes têm menos linhas para trabalhar e o desempenho geral da consulta melhora. O otimizador de consulta determina quando um bitmap é seletivo o bastante para ser útil e em quais operadores o filtro é aplicado. **Bitmap** é um operador físico.| 
|![Ícone do operador de pesquisa de indicador](../relational-databases/media/bookmark-lookup-32x.gif "Ícone do operador de pesquisa de indicador")|**Bookmark Lookup**|O operador **Bookmark Lookup** usa um indicador (ID da fila ou chave de clustering) para pesquisar a linha correspondente na tabela ou índice clusterizado. A coluna **Argument** contém o rótulo do indicador usado para procurar a linha na tabela ou índice clusterizado. A coluna **Argument** também contém o nome da tabela ou índice clusterizado no qual a linha é procurada. Se a cláusula WITH PREFETCH aparecer na coluna **Argument** , o processador de consulta determinará que convém usar a pré-busca assíncrona (read-ahead) ao procurar indicadores na tabela ou índice clusterizado.<br /><br /> Começando pelo [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)], o **Bookmark Lookup** não é usado. Em vez disso, **Key Lookup** e **RID Lookup** fornecem funcionalidade de pesquisa de indicador.| 
|None|**Branch Repartition**|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores **Parallelism** em uma região individual são chamados **Branch Repartition**. O iterador **Parallelism** no limite dessas duas regiões é chamado **Segment Repartition**. **Branch Repartition** e **Segment Repartition** são operadores lógicos.| 
|None|**Broadcast**|**Broadcast** tem um nó filho e *n* nós pai. **Broadcast** envia suas linhas de entrada para vários consumidores sob demanda. Cada consumidor adquire todas as linhas. Por exemplo, se todos os consumidores representarem lados de criação de uma junção hash, então serão criadas *n* cópias das tabelas de hash.| 
|![Ícone do operador para compilar hash](../relational-databases/media/build-hash.gif "Ícone do operador para compilar hash")|**Build Hash**|Indica a criação de uma tabela de hash de lote para um índice columnstore xVelocity de memória otimizada.| 
|None|**Cache**|O**Cache** é uma versão especializada do operador **Spool** . Ele armazena somente uma linha de dados. O**Cache** é um operador lógico. O**Cache** não é usado no [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].| 
|![Ícone do operador Excluir índice clusterizado](../relational-databases/media/clustered-index-delete-32x.gif "Ícone do operador Excluir índice clusterizado")|**Clustered Index Delete**|O operador **Clustered Index Delete** exclui linhas do índice clusterizado especificado na coluna Argumento do plano de execução da consulta. Se um predicado WHERE:() estiver presente na coluna Argument, somente as linhas que atenderem ao predicado serão excluídas.**Clustered Index Delete** é um operador físico.| 
|![Ícone do operador Inserir índice clusterizado](../relational-databases/media/clustered-index-insert-32x.gif "Ícone do operador Inserir índice clusterizado")|**Clustered Index Insert**|O operador de plano de execução **Clustered Index Insert** insere linhas de sua entrada no índice clusterizado especificado na coluna Argument. A coluna Argument também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se **Clustered Index Insert** não tiver nenhum filho para valores de inserção, a linha inserida será extraída do próprio operador **Insert** .**Clustered Index Insert** é um operador físico.| 
|![Ícone do operador Mesclar índice clusterizado](../relational-databases/media/clustered-index-merge-32x.gif "Ícone do operador Mesclar índice clusterizado")|**Clustered Index Merge**|O operador **Clustered Index Merge** aplica um fluxo de mesclagem de dados a um índice clusterizado. O operador exclui, atualiza ou insere linhas do índice clusterizado especificado na coluna **Argument** do operador. A operação real executada depende do valor de tempo de execução da coluna **ACTION** especificada na coluna **Argument** do operador. **Clustered Index Merge** é um operador físico.| 
|![Ícone do operador Verificar índice clusterizado](../relational-databases/media/clustered-index-scan-32x.gif "Ícone do operador Verificar índice clusterizado")|**Clustered Index Scan**|O operador **Clustered Index Scan** examina as linhas do índice clusterizado especificado na coluna Argument do plano de execução da consulta. Quando houver um predicado opcional WHERE:(), somente as linhas que atenderem ao predicado serão retornadas. Se a coluna Argument apresentar a cláusula ORDERED, o processador de consulta solicitou que a saída das linhas seja retornada na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento examinará o índice em modo ótimo, sem necessariamente classificar a saída. **Clustered Index Scan** é um operador lógico e físico.| 
|![Ícone do operador Buscar índice clusterizado](../relational-databases/media/clustered-index-seek-32x.gif "Ícone do operador Buscar índice clusterizado")|**Clustered Index Seek**|O operador **Clustered Index Seek** usa a habilidade de busca de índices para recuperar linhas de um índice cluster. A coluna **Argument** contém o nome do índice clusterizado que está sendo usado e o predicado SEEK:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que satisfazem esse predicado SEEK:(). Ele pode incluir também um predicado WHERE:(), onde o mecanismo de armazenamento avaliará em relação a todas as linhas que satisfizerem o predicado SEEK:(), mas isso é opcional e não usa índices para executar esse processo.<br /><br /> Se a coluna **Argumento** contiver a cláusula ORDERED, o processador de consulta determinou que as linhas fossem retornadas na ordem em que o índice clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice em modo ótimo, sem necessariamente classificar a saída. Permitir que a saída retenha sua ordenação pode ser menos eficiente do que produzir saída não classificada. Quando a palavra-chave LOOKUP aparecer, então uma consulta de marcador está sendo executada. No [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e em versões posteriores, o operador **Key Lookup** fornece a funcionalidade de consulta de marcador. **Clustered Index Seek** é um operador lógico e físico.| 
|![Ícone do operador Atualizar índice clusterizado](../relational-databases/media/clustered-index-update-32x.gif "Ícone do operador Atualizar índice clusterizado")|**Clustered Index Update**|O operador **Clustered Index Update** atualiza as linhas de entrada no índice clusterizado especificado na coluna **Argument** . Se um predicado WHERE:() estiver presente, somente as linhas que satisfazem esse predicado serão atualizadas. Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. Se um predicado DEFINE: () está presente, serão listados os valores que esse operador definir. Esses valores podem ser referenciados na cláusula SET ou em outro lugar dentro desse operador e em outro lugar dentro dessa consulta. **Clustered Index Update** é um operador lógico e físico.| 
|![Ícone do operador Recolher](../relational-databases/media/collapse-32x.gif "ícone do operador Recolher")|**Recolher**|O operador **Collapse** otimiza processamento de atualização. Quando uma atualização é executada, ela pode ser dividida (usando o operador **Split** ) em uma exclusão e uma entrada. A coluna **Argument** contém uma cláusula GROUP BY:() que especifica uma lista de colunas de chave. Se o processador de consultas encontrar linhas adjacentes que incluem e inserem os mesmos valores de chave, ele substituirá essas operações separadas por uma operação de atualização única e mais eficiente. **Collapse** é um operador lógico e físico.| 
|![Verificação de Índice Columnstore](../relational-databases/media/columnstoreindexscan.gif "Verificação de Índice Columnstore")|**Verificação de Índice Columnstore**|O operador **Columnstore Index Scan** examina o índice columnstore especificado na coluna **Argument** do plano de execução da consulta.| 
|![Ícone do operador Computar escalar](../relational-databases/media/compute-scalar-32x.gif "Ícone do operador Computar escalar")|**Compute Scalar**|O operador **Compute Scalar** avalia uma expressão para produzir um valor escalar computado. Isso pode ser retornado ao usuário, ter referência em outro lugar na consulta, ou ambos. Um exemplo de ambos está em um predicado de filtro ou predicado de junção. O**Compute Scalar** é um operador lógico e físico.<br /><br /> Operadores**Compute Escalar** que aparecem em planos de execução gerados por SET STATISTICS XML podem não conter o elemento **RunTimeInformation** . Em planos de execução gráficos, **Linhas Reais**, **Religações Reais**e **Retrocessos Reais** podem estar ausentes na janela **Propriedades** quando a opção **Incluir Plano de Execução Real** estiver selecionada em [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Quando isto acontece, significa que, embora os operadores tenham sido usados no plano de consulta compilado, o trabalho foi executado por outros operadores no plano de consulta de tempo de execução. Observe também que o número de execuções na saída de plano de execução gerada por SET STATISTICS PROFILE é equivalente à soma de reassociações e retrocessos em planos de execução gerados por SET STATISTICS XML.| 
|![Ícone do operador Concatenação](../relational-databases/media/concatenation-32x.gif "Ícone do operador Concatenação")|**Concatenation**|O operador **Concatenation** verifica várias entradas, retornando cada linha verificada. **Concatenation** normalmente é usado para implementar a construção UNION ALL [!INCLUDE[tsql](../includes/tsql-md.md)] . O operador físico **Concatenation** tem duas ou mais entradas e uma saída. Concatenation copia linhas do primeiro fluxo de entrada ao fluxo de saída e repete essa operação para cada fluxo de entrada adicional. **Concatenation** é um operador lógico e físico.| 
|![Ícone do operador Verificação de constante](../relational-databases/media/constant-scan-32x.gif "Ícone do operador Verificação de constante")|**Constant Scan**|O operador **Constant Scan** introduz uma ou mais linhas constantes em uma consulta. Um operador **Compute Scalar** é frequentemente usado após uma **Constant Scan** para acrescentar colunas a uma linha produzida pelo operador **Constant Scan** .| 
|![Ícone de elemento de linguagem Converter (Mecanismo de Banco de Dados)](../relational-databases/media/convert-32x.gif "Ícone de elemento de linguagem Converter (Mecanismo de Banco de Dados)")|**Converter**|O operador **Convert** converte um tipo de dados escalar em outro. **Convert** é um elemento de linguagem.| 
|None|**Cross Join**|O operador **Cross Join** une cada linha da primeira entrada (superior) a cada linha da segunda entrada (inferior). **Cross Join** é um operador lógico.| 
|None|**Cursor**|Os operadores lógicos e físicos **Cursor** são usados para descrever como é executada uma consulta ou atualização que envolva operações de cursor. Os operadores físicos descrevem o algoritmo de implementação físico usado para processar o cursor; por exemplo, usando um cursor controlado por conjunto de chaves. Cada etapa na execução de um cursor envolve um operador físico. Os operadores lógicos descrevem uma propriedade do cursor, como quando o cursor é somente leitura.<br /><br /> Operadores lógicos incluem Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, Secondary e Synchronous.<br /><br /> Operadores físicos incluem Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.| 
|![Ícone do operador de cursor Cursor catchall](../relational-databases/media/cursor-catch-all.gif "Ícone do operador de cursor Cursor catchall")|**catchall**|O ícone catchall é exibido quando a lógica que produz planos de execução gráficos não puder encontrar um ícone viável para o iterador. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para elementos de linguagem [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Ícone do elemento Declarar linguagem](../relational-databases/media/declare-32x.gif "Ícone do elemento Declarar linguagem")|**Declare**|O operador **Declare** aloca uma variável local no plano de consulta. **Declare** é um elemento de linguagem.| 
|![Ícone do operador Excluir (Mecanismo de Banco de Dados)](../relational-databases/media/delete-32x.gif "Ícone do operador Excluir (Mecanismo de Banco de Dados)")|**Delete (excluir)**|O operador **Delete** efetua a exclusão em linhas de objeto que atendem ao predicado opcional na coluna **Argumento** .| 
|![Ícone do operador Excluir verificação](../relational-databases/media/delete-scan-32x.gif "Ícone do operador Excluir verificação")|**Deleted Scan**|O operador **Deleted Scan** examina a tabela excluída em um gatilho.| 
|None|**Distinct Sort**|O operador lógico **Distinct Sort** verifica a entrada, removendo duplicatas e fazendo classificação pelas colunas especificadas no predicado DISTINCT ORDER BY:() da coluna **Argument** . **Distinct Sort** é um operador lógico.| 
|None|**Distinct**|O operador **Distinct** remove duplicatas de um conjunto de linhas ou de uma coleção de valores. **Distinct** é um operador lógico.| 
|![Ícone do operador Distribuir paralelismo de fluxos](../relational-databases/media/parallelism-distribute-stream.gif "Ícone do operador Distribuir paralelismo de fluxos")|**Distribute Streams**|O operador **Distribute Streams** só é usado em planos de consulta paralelos. O operador **Distribute Streams** leva um fluxo de entrada simples de registros e produz fluxos de saída múltiplos. O conteúdo do registro e o formato não são alterados. Cada registro do fluxo de entrada aparece em um dos fluxos de saída. Este operador preserva automaticamente a ordem relativa dos registros de entrada nos fluxos de saída. Normalmente, são usadas operações de hash para decidir a qual fluxo de saída pertence um determinado registro de entrada.<br /><br /> Se a saída for particionada, a coluna **Argument** conterá um predicado PARTITION COLUMNS:() e as colunas de particionamento. **Distribute Streams** é um operador lógico| 
|![Ícone do operador de cursor dinâmico](../relational-databases/media/dynamic-32x.gif "Ícone do operador de cursor dinâmico")|**Dinâmicos**|O operador **Dynamic** usa um cursor que pode ver todas as alterações feitas por outros.| 
|![Ícone do operador Buscar cursor de consulta](../relational-databases/media/fetch-query-32x.gif "Ícone do operador Buscar cursor de consulta")|**Fetch Query**|O operador **Fetch Query** recupera linhas quando é feita uma busca em um cursor.| 
|![Ícone do operador Filtrar (Mecanismo de Banco de Dados)](../relational-databases/media/filter-32x.gif "Ícone do operador Filtrar (Mecanismo de Banco de Dados)")|**Filter**|O operador **Filter** examina a entrada, retornando apenas as linhas que satisfazem a expressão de filtro (predicado) que aparece na coluna **Argument** .| 
|None|**Flow Distinct**|O operador lógico **Flow Distinct** examina a entrada, removendo duplicatas. Enquanto o operador **Distinct** consome toda a entrada antes de produzir qualquer saída, o operador **FlowDistinct** retorna cada linha como foi obtida da entrada (a menos que a fila seja uma duplicata: nesse caso ela é descartada).| 
|![Ícone do operador Verificação de Referências de Chave Estrangeira](../relational-databases/media/fk-references-32x.gif "Ícone do operador Verificação de Referências de Chave Estrangeira")|**Verificação de Referências de Chave Estrangeira**|O operador **Verificação de Referências de Chave Estrangeira** executa verificações de integridade referencial no local, comparando a linha modificada com as linhas nas tabelas de referência para verificar se a modificação não afetará a integridade referencial. O operador **Verificação de Referências de Chave Estrangeira** é usado quando mais de 253 referências de chave estrangeira existem na mesma chave primária ou exclusiva. **Verificação de Referências de Chave Estrangeira** é um operador lógico e físico.| 
|None|**Full Outer Join**|O operador lógico **Full Outer Join** retorna cada linha que satisfaz o predicado de junção da primeira entrada (parte superior) associada a cada linha da segunda entrada (parte inferior). Ele também retorna linhas:<br /><br /> \- Da primeira entrada que não teve nenhuma correspondência na segunda entrada.<br /><br /> \- Da segunda entrada que não teve nenhuma correspondência na primeira entrada.<br /><br /> A entrada que não contém os valores correspondentes é retornada como um valor nulo. **Full Outer Join** é um operador lógico.| 
|![Ícone do operador Coletar paralelismo de fluxos](../relational-databases/media/parallelism-32x.gif "Ícone do operador Coletar paralelismo de fluxos")|**Gather Streams**|O operador **Gather Streams** só é usado em planos de consulta paralelos. O operador **Gather Streams** consome vários fluxos de entrada e produz um único fluxo de saída de registros ao combinar os fluxos de entrada. O conteúdo do registro e o formato não são alterados. Se este operador for preservador da ordem, todos os fluxos de entrada deverão ser ordenados. Se a saída for ordenada, a coluna **Argument** conterá um predicado ORDER BY:() e os nomes das colunas que estão sendo ordenadas. **Gather Streams** é um operador lógico.| 
|![Ícone do operador Correspondência de hash](../relational-databases/media/hash-match-32x.gif "Ícone do operador Correspondência de hash")|**Hash Match**|O operador **Hash Match** cria uma tabela de hash computando um valor de hash para cada linha da entrada criada. Um predicado HASH:() com uma lista de colunas usadas para criar um valor de hash aparece na coluna **Argument** . Então, para cada fila de sondagem (conforme aplicável), ela computa um valor de hash (usando a mesma função de hash) e procura correspondências na tabela de hash. Se um predicado residual estiver presente (identificado por RESIDUAL:() na coluna **Argument** ), esse predicado também deverá ser atendido para que as linhas sejam consideradas uma correspondência. O comportamento depende da operação lógica que está sendo executada:<br /><br /> \- Para qualquer junção, use a primeira entrada (superior) para criar a tabela de hash e a segunda (inferior) para sondar a tabela de hash. As correspondências de saída (ou não correspondências) conforme determinadas pelo tipo de junção. Se várias junções usam a mesma coluna de junção, essas operações serão agrupadas em uma equipe de hash.<br /><br /> \- Para os operadores distintos ou de agregação, use a entrada para criar a tabela de hash (removendo duplicatas e computando quaisquer expressões de agregação). Quando a tabela de hash for criada, verifique a tabela e saída de todas as entradas.<br /><br /> \- Para o operador de união, use a primeira entrada para criar a tabela de hash (removendo duplicatas). Use a segunda entrada (que não deve ter uma duplicata) para sondar a tabela de hash, retornando todas linhas sem correspondência e, então, verifique a tabela de hash e retorne todas as entradas.<br /><br /> **Hash Match** é um operador físico.| 
|![Ícone do elemento de linguagem If](../relational-databases/media/if-32x.gif "Ícone do elemento de linguagem If")|**Se**|O operador **If** executa processamento condicional com base em uma expressão. **If** é um elemento de linguagem.| 
|None|**Inner Join**|O operador lógico **Inner Join** retorna cada linha que satisfaz a junção da primeira entrada (superior) com a segunda entrada (inferior).| 
|![Ícone do operador Inserir (Mecanismo de Banco de Dados)](../relational-databases/media/insert-32x.gif "Ícone do operador Inserir (Mecanismo de Banco de Dados)")|**Insert**|O operador lógico **Insert** insere cada linha de sua entrada no objeto especificado na coluna **Argument** . O operador físico é o operador **Table Insert**, **Index Insert**ou **Clustered Index Insert** .| 
|![Ícone do operador Verificação inserida](../relational-databases/media/inserted-scan-32x.gif "Ícone do operador Verificação inserida")|**Inserted Scan**|O operador **Inserted Scan** verifica a tabela **inserida** . O**Inserted Scan** é um operador lógico e físico.| 
|![Ícone do elemento de linguagem intrínseca](../relational-databases/media/intrinsic-32x.gif "Ícone do elemento de linguagem intrínseca")|**Intrinsic**|O operador **Intrinsic** invoca uma função [!INCLUDE[tsql](../includes/tsql-md.md)] interna. **Intrinsic** é um elemento de linguagem.| 
|![Ícone do operador catchall de iterador](../relational-databases/media/iterator-catch-all.gif "Ícone do operador catchall de iterador")|**Iterador**|O ícone catchall **Iterator** é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|![Ícone do operador de pesquisa de indicador](../relational-databases/media/bookmark-lookup-32x.gif "Ícone do operador de pesquisa de indicador")|**Key Lookup**|O operador **Key Lookup** é uma pesquisa de indicadores em uma tabela com um índice clusterizado. A coluna **Argumento** contém o nome do índice clusterizado e a chave de clusterização usada para procurar a linha no índice clusterizado. **Key Lookup** é sempre acompanhada por um operador **Loops** . Se a cláusula WITH PREFETCH aparecer na coluna **Argument** , o processador de consultas determinará que o ideal é usar a pré-busca assíncrona (read-ahead) ao observar marcadores no índice clusterizado.<br /><br /> O uso de um operador **Key Lookup** em um plano de consulta indica que a consulta pode se beneficiar de ajuste de desempenho. Por exemplo, o desempenho da consulta pode ser melhorado adicionando-se um índice de cobertura.| 
|![Ícone do operador de cursor de conjunto de chaves](../relational-databases/media/keyset-32x.gif "Ícone do operador de cursor de conjunto de chaves")|**Keyset**|O operador **Keyset** usa um cursor que pode visualizar atualizações, mas não inserções feitas por outros.| 
|![Ícone catchall de elemento de linguagem](../relational-databases/media/language-construct-catch-all.gif "Ícone catchall de elemento de linguagem")|**Elemento Language**|O ícone catchall **Language Element** é exibido quando um ícone adequado para o iterador não é encontrado pela lógica que produz planos de execução gráfica. O ícone catchall não indica necessariamente uma condição de erro. Há três ícones catchall: azul (para iteradores), laranja (para cursores) e verde (para construções de linguagem do [!INCLUDE[tsql](../includes/tsql-md.md)] ).| 
|None|**Left Anti Semi Join**|O operador **Left Anti Semi Join** retorna cada linha da primeira entrada (parte superior) quando não existe uma linha correspondente na segunda entrada (parte inferior). Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Left Anti Semi Join** é um operador lógico.| 
|None|**Left Outer Join**|O operador **Left Outer Join** retorna cada linha que satisfaz a junção da primeira entrada (parte superior) com a segunda entrada (parte inferior). Ele também retorna linhas da primeira entrada que não teve linhas correspondentes na segunda entrada. As linhas não correspondentes na segunda entrada são retornadas como valores nulos. Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Left Outer Join** é um operador lógico.| 
|None|**Left Semi Join**|O operador **Left Semi Join** retornará todas as linhas da segunda entrada (inferior) quando existir uma linha correspondente na primeira entrada (superior). Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Left Semi Join** é um operador lógico.| 
|![Ícone do operador Registrar verificação de linha](../relational-databases/media/log-row-scan-32x.gif "Ícone do operador Registrar verificação de linha")|**Log Row Scan**|O operador **Log Row Scan** examina o log de transações. **Log Row Scan** é um operador lógico e físico.| 
|![Ícone do operador Mesclar intervalo](../relational-databases/media/merge-interval-32x.gif "Ícone do operador Mesclar intervalo")|**Merge Interval**|O operador **Merge Interval** mescla vários intervalos (com sobreposição potencial) para produzir intervalos mínimo, não sobrepostos, usados para buscar entradas de índice. Esse operador aparece geralmente sobre um ou mais operadores **Compute Scalar** sobre operadores **Constant Scan** que constroem os intervalos (representados como colunas em uma linha) que esse operador mescla. **Merge Interval** é um operador lógico e físico.| 
|![Ícone do operador Mesclar junção](../relational-databases/media/merge-join-32x.gif "Ícone do operador Mesclar junção")|**Junção de Mesclagem**|O operador **Merge Join** executa a inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e operações lógicas de união.<br /><br /> Na coluna **Argument** , o operador **Merge Join** contém um predicado MERGE:() se a operação estiver executando uma junção de um para muitos, ou um predicado MANY-TO-MANY MERGE:() se a operação estiver executando uma junção de muitos para muitos. A coluna **Argument** também inclui uma lista de colunas separada por vírgula usada para executar a operação. O operador **Merge Join** requer duas entradas classificadas em suas respectivas colunas, possivelmente inserindo operações de classificação explícitas no plano de consulta. A junção de mesclagem é particularmente eficaz se não for exigida uma classificação explícita, por exemplo, se houver um índice da árvore B adequado no banco de dados, ou se a ordem de classificação puder ser explorada para diversas operações, como uma junção de mesclagem e um agrupamento com acúmulo. **Merge Join** é um operador físico.| 
|![Ícone do operador Loops aninhados](../relational-databases/media/nested-loops-32x.gif "Ícone do operador Loops aninhados")|**Nested Loops**|O operador **Nested Loops** executa operações lógicas de junção interna, junção externa esquerda, left semi join e left anti semi join. As junções de loops aninhados executam uma pesquisa na tabela interna para cada linha da tabela externa, normalmente usando um índice. O processador de consultas decide, com base em custos previstos, se classificará a entrada externa para aprimorar a localidade das pesquisas no índice da entrada interna. Qualquer linha que atende ao predicado (opcional) na coluna **Argument** é retornada como aplicável, com base na operação lógica em execução. **Nested Loops** é um operador físico.| 
|![Ícone do operador Excluir índice não clusterizado](../relational-databases/media/nonclust-index-delete-32x.gif "Ícone do operador Excluir índice não clusterizado")|**Nonclustered Index Delete**|O operador **Nonclustered Index Delete** exclui linhas de entrada do índice não cluster especificado na coluna **Argument** . **Nonclustered Index Delete** é um operador físico.| 
|![Ícone do operador Inserir índice não clusterizado](../relational-databases/media/nonclust-index-insert-32x.gif "Ícone do operador Inserir índice não clusterizado")|**Index Insert**|O operador **Index Insert** insere linhas de sua entrada no índice não clusterizado especificado na coluna **Argument** . A coluna **Argument** também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. **Index Insert** é um operador físico.| 
|![Ícone do operador Verificar índice não clusterizado](../relational-databases/media/nonclustered-index-scan-32x.gif "Ícone do operador Verificar índice não clusterizado")|**Index Scan**|O operador **Index Scan** recupera todas as linhas do índice não clusterizado especificado na coluna **Argument** . Se um predicado opcional WHERE:() aparecer na coluna **Argument** , somente as linhas que atenderem ao predicado serão retornadas. **Index Scan** é um operador lógico e físico.| 
|![Ícone do operador Buscar índice não clusterizado](../relational-databases/media/index-seek-32x.gif "Ícone do operador Buscar índice não clusterizado")|**Index Seek**|O operador **Index Seek** usa a capacidade de busca de índices para recuperar linhas de um índice não clusterizado. A coluna **Argument** contém o nome do índice não clusterizado usado. Também contém o predicado SEEK:(). O mecanismo de armazenamento usa o índice para processar somente as linhas que atendem ao predicado SEEK:(). Ele pode incluir opcionalmente um predicado WHERE:(), que o mecanismo de armazenamento avaliará em relação a todas as linhas que atenderem ao predicado SEEK:() (não usa os índices para fazer isso). Se a coluna **Argument** contém a cláusula ORDERED, o processador de consulta determinou que as linhas fossem retornadas na ordem em que o índice não clusterizado as classificou. Se a cláusula ORDERED não estiver presente, o mecanismo de armazenamento pesquisará o índice no modo ideal (o que não garante que a saída será classificada). Permitir que a saída retenha sua ordenação pode ser menos eficiente que produzir saída não classificada. **Index Seek** é um operador lógico e físico.| 
|![Ícone do operador Spool de índice não clusterizado](../relational-databases/media/index-spool-32x.gif "Ícone do operador Spool de índice não clusterizado")|**Index Spool**|O operador físico **Index Spool** contém um predicado SEEK:() na coluna **Argument** . O operador **Index Spool** examina suas linhas de entrada, colocando uma cópia de cada linha em um arquivo spool oculto (armazenado no banco de dados **tempdb** que existe somente durante o tempo de vida da consulta) e cria um índice não clusterizado nas linhas. Isto permite que você use o recurso de busca de índices para produzir somente as linhas que correspondem ao predicado SEEK: (). Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada.| 
|![Ícone do operador Atualizar índice não clusterizado](../relational-databases/media/nonclust-index-update-32x.gif "Ícone do operador Atualizar índice não clusterizado")|**Nonclustered Index Update**|O operador físico **Nonclustered Index Update** atualiza linhas de sua entrada no índice não clusterizado especificado na coluna **Argument** . Se um predicado SET:() estiver presente, cada coluna atualizada será definida com esse valor. **Nonclustered Index Update** é um operador físico.| 
|![Ícone do operador Inserir índice online](../relational-databases/media/online-index-32x.gif "Ícone do operador Inserir índice online")|**Online Index Insert**|O operador físico **Online Index Insert** indica que uma operação de criação, alteração ou remoção de índice é executada online. Ou seja, os dados da tabela subjacente permanecem disponíveis para usuários durante a operação de índice.| 
|None|**Parallelism**|<a name="exchange"></a> O operador **Parallelism** (ou iterador de troca) executa operações lógicas de fluxos de distribuição, fluxos de coleta e fluxos de repartição. As colunas **Argument** podem conter um predicado PARTITION COLUMNS:() com uma lista separada por vírgula das colunas que estão sendo particionadas. As colunas **Argument** também podem conter um predicado ORDER BY:(), listando as colunas para preservar a ordem de classificação durante o particionamento. **Parallelism** é um operador físico. Para saber mais sobre o operador Parallelism, confira a [série de blog de Craig Freedman](https://blogs.msdn.microsoft.com/craigfr/tag/parallelism/).<br /><br />**Observação:** se uma consulta tiver sido compilada como uma consulta paralela, mas no tempo de execução for executada como consulta serial, a saída do Plano de Execução gerada por SET STATISTICS XML ou pela opção **Incluir Plano de Execução Real** no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] não incluirá o elemento **RunTimeInformation** para o operador **Parallelism**. Na saída SET STATISTICS PROFILE, as contagens reais de linha e número real de execuções exibirão zeros para o operador **Parallelism** . Quando uma dessas condições ocorre, significa que o operador **Parallelism** só foi usado durante a compilação da consulta e não no plano de consulta em tempo de execução. Observe que às vezes os planos de consulta paralelos serão executados em série, se houver uma carga simultânea grande no servidor.| 
|![Ícone do operador Verificar tabela de parâmetro](../relational-databases/media/parameter-table-scan-32x.gif "Ícone do operador Verificar tabela de parâmetro")|**Parameter Table Scan**|O operador **Parameter Table Scan** examina uma tabela que está atuando como um parâmetro na consulta atual. Normalmente, isto é usado para consultas INSERT dentro de um procedimento armazenado. **Parameter Table Scan** é um operador lógico e físico.| 
|None|**Partial Aggregate**|**Agregação parcial** é usada em planos paralelos. Aplica uma função de agregação para tantas linhas de entrada quanto possíveis de forma que gravar em disco (conhecido como "derramamento") não é necessário. **Hash Match** é o único operador físico (iterator) que implementa agregação de partição. **Agregação parcial** é um operador lógico.| 
|![Ícone do operador Cursor de consulta de população](../relational-databases/media/poulation-query-32x.gif "Ícone do operador Cursor de consulta de população")|**Population Query**|O operador **Population Query** popula a tabela de trabalho de um cursor quando o cursor é aberto.| 
|![Ícone do operador Atualizar cursor de consulta](../relational-databases/media/refresh-query-32x.gif "Ícone do operador Atualizar cursor de consulta")|**Refresh Query**|O operador **Refresh Query** busca dados atuais para linhas do buffer de busca.| 
|![Ícone do operador Exclusão remota](../relational-databases/media/remote-delete-32x.gif "Ícone do operador Exclusão remota")|**Remote Delete**|O operador **Remote Delete** exclui as linhas de entrada a partir de um objeto remoto. **Remote Delete** é um operador lógico e físico.| 
|![Operador de plano de execução Buscar índice remoto](../relational-databases/media/remote-index-scan-32x.gif "Operador de plano de execução Buscar índice remoto")|**Remote Index Scan**|O operador **Remote Index Scan** examina o índice remoto especificado na coluna Argument. **Verificação de Índice Remoto** é um operador lógico e físico.| 
|![Operador de plano de execução Buscar índice remoto](../relational-databases/media/remote-index-seek-32x.gif "Operador de plano de execução Buscar índice remoto")|**Remote Index Seek**|O operador de **Busca de Índice Remoto** usa a busca de um objeto de índice remoto para recuperar linhas. A coluna **Argument** contém o nome do índice remoto que está sendo usado e o predicado SEEK:(). **Busca de Índice Remoto** é um operador lógico e físico.| 
|![Ícone do operador Inserção remota](../relational-databases/media/remote-insert-32x.gif "Ícone do operador Inserção remota")|**Remote Insert**|O operador **Remote Insert** insere linhas de entrada em um objeto remoto. O**Remote Insert** é um operador lógico e físico.| 
|![Ícone do operador Consulta remota](../relational-databases/media/remote-query-32x.gif "Ícone do operador Consulta remota")|**Remote Query**|O operador **Remote Query** submete uma consulta a uma fonte remota. O texto da consulta enviado ao servidor remoto aparece na coluna **Argument** . **Remote Query** é um operador lógico e físico.| 
|![Ícone do operador Verificação remota](../relational-databases/media/remote-scan-32x.gif "Ícone do operador Verificação remota")|**Remote Scan**|O operador **Remote Scan** examina um objeto remoto. O nome do objeto remoto aparece na coluna **Argument** . **Remote Scan** é um operador lógico e físico.| 
|![Ícone do operador Atualização remota](../relational-databases/media/remote-update-32x.gif "Ícone do operador Atualização remota")|**Remote Update**|O operador **Remote Update** atualiza a linha de entrada em um objeto remoto. **Remote Update** é um operador lógico e físico.| 
|![Ícone do operador Reparticionar paralelismo de fluxos](../relational-databases/media/parallelism-repartition-stream.gif "Ícone do operador Reparticionar paralelismo de fluxos")|**Repartition Streams**|O operador **Repartition Streams** (ou iterador de troca) consome vários fluxos e produz vários fluxos de registros. O conteúdo do registro e o formato não são alterados. Se o otimizador de consulta usar um filtro de bitmap, o número de linhas no fluxo de saída será reduzido. Cada registro de um fluxo de entrada é colocado em um fluxo de saída. Se esse operador for preservador de ordem, todos os fluxos de entrada deverão ser ordenados e mesclados em vários fluxos de saída ordenados. Se a saída for particionada, a coluna **Argument** conterá um predicado PARTITION COLUMNS:() e as colunas de particionamento. Se a saída for ordenada, a coluna **Argument** conterá um predicado ORDER BY:() e as colunas que estão sendo ordenadas. **Reparticionar Fluxos** atua como um operador lógico. O operador é usado somente em planos de consulta paralelos.| 
|![Ícone do elemento Linguagem do resultado](../relational-databases/media/result-32x.gif "Ícone do elemento Linguagem do resultado")|**Resultado**|O operador **Result** consiste nos dados retornados ao término de um plano de consulta. Normalmente, é o elemento raiz de um plano de execução. **Result** é um elemento de linguagem.| 
|![Ícone do operador Pesquisa de RID](../relational-databases/media/rid-nonclust-locate-32x.gif "Ícone do operador Pesquisa de RID")|**RID Lookup**|**RID Lookup** é um indicador de pesquisa em um heap que usa um RID (identificador de linha) fornecido. A coluna **Argument** contém o rótulo de indicador usado para pesquisar a linha na tabela e o nome da tabela em que a linha é pesquisada. **RID Lookup** sempre é acompanhado por NESTED LOOP JOIN. **RID Lookup** é um operador físico. Para obter mais informações sobre pesquisas de indicador, consulte o artigo sobre[pesquisa de indicadores](https://go.microsoft.com/fwlink/?LinkId=132568)no blog do SQL Server no MSDN.| 
|![Ícone do operador Spool de contagem de linha](../relational-databases/media/remote-count-spool-32x.gif "Ícone do operador Spool de contagem de linha")|**Row Count Spool**|O operador **Row Count Spool** examina a entrada, contando quantas linhas estão presentes e retornando o mesmo número de linhas sem qualquer dado nelas. Esse operador é usado quando é importante a verificação da existência de linhas, em vez dos dados contidos nas linhas. Por exemplo, se um operador **Nested loops** executa uma operação left semi join e o predicado de junção se aplica à entrada interna, um spool de contagem de linhas poderá ser colocado no topo da entrada interna do operador **Nested loops** . Em seguida, o operador **Nested Loops** poderá determinar quantas linhas saem do spool de contagem de linhas (porque não são necessários dados reais do lado interno) para determinar se retornará a linha exterior. O**Row Count Spool** é um operador físico.| 
|None|**Right Anti Semi Join**|O operador **Right Anti Semi Join** efetua a saída de cada linha a partir da segunda (inferior) entrada quando não existe uma linha correspondente na primeira (superior) entrada. Uma linha correspondente está definida como uma linha que atende ao predicado na coluna **Argument** (se nenhum predicado existir, cada linha será uma linha correspondente). **Right Anti Semi Join** é um operador lógico.| 
|None|**Right Outer Join**|O operador **Right Outer Join** retorna cada linha que satisfaz a junção da segunda entrada (parte inferior) associada a cada linha correspondente da primeira entrada (parte superior). Ele também retorna linhas da segunda entrada que não tiveram linhas correspondentes na primeira entrada, unidas com NULL. Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Right Outer Join** é um operador lógico.| 
|None|**Right Semi Join**|O operador **Right Semi Join** retornará todas as linha da segunda entrada (inferior) quando existir uma linha correspondente na primeira entrada (superior). Se não houver nenhum predicado de junção na coluna **Argument** , cada linha será uma linha correspondente. **Right Semi Join** é um operador lógico.| 
|![Ícone do operador Segmento](../relational-databases/media/segment-32x.gif "Ícone do operador Segmento")|**Segment**|**Segment** é um operador lógico e físico. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. Essas colunas são mostradas como argumentos no operador **Segment** . O operador produz então um segmento por vez.| 
|![Ícone do operador Sequência](../relational-databases/media/sequence-32x.gif "Ícone do operador Sequência")|**Sequência**|O operador **Sequence** conduz amplos planos de atualização. Em termos funcionais, ele executa cada entrada em sequência (da parte superior até a inferior). Cada entrada normalmente é uma atualização de um objeto diferente. Ele retorna somente as linhas que vêm de sua última entrada (parte inferior). **Sequence** é um operador lógico e físico.| 
|![Ícone do operador Projeto de sequência](../relational-databases/media/sequence-project-32x.gif "Ícone do operador Projeto de sequência")|**Projeto de sequência**|O operador **Sequence Project** adiciona colunas para executar computações sobre um conjunto ordenado. Divide a entrada definida em segmentos baseado no valor de uma ou mais colunas. O operador produz então um segmento por vez. Estas colunas são mostradas como argumentos no operador **Sequence Project** . **Sequence Project** é um operador lógico e físico.| 
|None|**Segment Repartition**|Às vezes, em um plano de consulta paralelo, há regiões conceituais de iteradores. Todos os iteradores dentro de tal região podem ser executados por threads paralelos. As próprias regiões devem ser executadas em série. Alguns dos iteradores **Parallelism** em uma região individual são chamados **Branch Repartition**. O iterador **Parallelism** no limite dessas duas regiões é chamado **Segment Repartition**. **Branch Repartition** e **Segment Repartition** são operadores lógicos.| 
|![Ícone do operador Cursor de instantâneo](../relational-databases/media/snapshot-32x.gif "Ícone do operador Cursor de instantâneo")|**Instantâneo**|O operador **Snapshot** cria um cursor que não encontra mudanças feitas pelos outros.| 
|![Ícone do operador Classificar](../relational-databases/media/sort-32x.gif "Ícone do operador Classificar")|**Sort**|O operador **Sort** classifica todas as linhas de entrada. A coluna **Argument** contém um predicado DISTINCT ORDER BY:() se duplicatas forem removidas por esta operação, ou um predicado ORDER BY:() com uma lista separada por vírgula das colunas que estão sendo classificadas. As colunas são prefixadas com o valor ASC se as colunas forem classificadas em ordem crescente, ou o valor DESC se as colunas forem classificadas em ordem decrescente. **Sort** é um operador lógico e físico.| 
|![Ícone do operador Dividir](../relational-databases/media/split-32x.gif "Ícone do operador Dividir")|**Split**|O operador **Split** é usado para otimizar o processamento da atualização. Ele divide cada operação de atualização em uma operação de exclusão e inserção. **Split** é um operador lógico e físico.| 
|![Ícone do operador spool](../relational-databases/media/spool-32x.gif "Ícone do operador spool")|**Eager Spool**|O operador **Eager Spool** pega toda a entrada, armazenando cada linha em um objeto temporário oculto armazenado no banco de dados **tempdb** . Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Eager Spool** cria seu arquivo de spool de maneira “ávida”, ou seja, cada vez que o operador pai do spool solicita a primeira linha, o operador de spool consome todas as linhas de seu operador de entrada e as armazena no spool. O**Eager Spool** é um operador lógico.| 
|![Ícone do operador spool](../relational-databases/media/spool-32x.gif "Ícone do operador spool")|**Lazy Spool**|O operador lógico **Lazy Spool** armazena cada linha de sua entrada em um objeto temporário oculto armazenado no banco de dados **tempdb** . Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada. Se a reassociação for necessária, os dados em spool serão descartados e o objeto de spool será recriado por meio do novo exame da entrada (religação). O operador **Lazy Spool** cria seu arquivo de spool de maneira “lenta”, ou seja, sempre que o operador pai do spool solicita uma linha, o operador do spool obtém uma linha de seu operador de entrada e a armazena no spool, em vez de consumir todas as linhas de uma vez. O Lazy Spool é um operador lógico.| 
|![Ícone do operador spool](../relational-databases/media/spool-32x.gif "Ícone do operador spool")|**Spool**|O operador **Spool** salva um resultado de consulta intermediário no banco de dados **tempdb** .| 
|![Ícone do operador Agregação de fluxo](../relational-databases/media/stream-aggregate-32x.gif "Ícone do operador Agregação de fluxo")|**Stream Aggregate**|O operador **Stream Aggregate** agrupa linhas por uma ou mais colunas e, em seguida, calcula uma ou mais expressões de agregação retornadas pela consulta. A saída deste operador pode ser referenciada por operadores posteriores na consulta, retornada ao cliente, ou ambos. O operador **Stream Aggregate** requer a entrada de dados ordenada pelas colunas dentro de seus grupos. O otimizador usará um operador **Sort** antes desse operador se os dados ainda não estiverem classificados em função de um operador **Sort** anterior ou devido a uma busca ou análise de índice ordenado. Na instrução SHOWPLAN_ALL ou no plano de execução gráfica no [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], são listadas as colunas no predicado GROUP BY na coluna **Argument** , e as expressões de agregação são listadas na coluna **Defined Values** . **Stream Aggregate** é um operador físico.| 
|![Ícone do operador Comutador](../relational-databases/media/switch-32x.gif "Ícone do operador Comutador")|**Opção**|**Switch** é um tipo especial de iterador de concatenação que tem *n* entradas. Uma expressão é associada a cada operador **Switch** . Dependendo do valor retornado da expressão (entre 0 e *n*-1), **Switch** copia o fluxo de entrada apropriado ao fluxo de saída. Um uso de **Switch** é implementar planos de consulta envolvendo cursores de avanço rápido com determinados operadores, como o operador **TOP** . **Switch** é um operador lógico e físico.| 
|![Ícone do operador Exclusão de tabela](../relational-databases/media/table-delete-32x.gif "Ícone do operador Exclusão de tabela")|**Table Delete**|O operador físico **Table Delete** exclui linhas da tabela especificadas na coluna **Argument** do plano de execução da consulta.| 
|![Ícone do operador Inserção de tabela](../relational-databases/media/table-insert-32x.gif "Ícone do operador Inserção de tabela")|**Table Insert**|O operador **Table Insert** insere linhas de sua entrada na tabela especificada na coluna **Argument** do plano de execução de consulta. A coluna **Argument** também contém um predicado SET:(), que indica o valor para o qual cada coluna está definida. Se **Table Insert** não tiver nenhum filho para valores de inserção, então a linha inserida será tirada do próprio operador Insert. **Table Insert** é um operador físico.| 
|![Operador Mesclar tabela](../relational-databases/media/table-merge-32x.gif "Operador Mesclar tabela")|**Table Merge**|O operador **Table Merge** aplica um fluxo de dados de mesclagem a um heap. O operador exclui, atualiza ou insere linhas na tabela especificada na coluna **Argument** do operador. A operação real executada depende do valor do tempo de execução da coluna **ACTION** especificada na coluna **Argument** do operador. **Table Merge** é um operador físico.| 
|![Ícone do operador Verificação de tabela](../relational-databases/media/table-scan-32x.gif "Ícone do operador Verificação de tabela")|**Table Scan**|O operador **Table Scan** recupera todas as linhas da tabela especificada na coluna **Argument** do plano de execução da consulta. Se um predicado WHERE:() aparecer na coluna **Argument** , somente as linhas que atenderem ao predicado serão retornadas. **Table Scan** é um operador lógico e físico.| 
|![Ícone do operador Spool de tabela](../relational-databases/media/table-spool-32x.gif "Ícone do operador Spool de tabela")|**Table Spool**|O operador **Table Spool** examina a entrada e coloca uma cópia de cada linha em uma tabela de spool oculta que é armazenada no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) e existe durante o tempo de vida da consulta. Se for feito o retrocesso do operador (por exemplo, por um operador **Nested Loops** ) sem que haja necessidade de reassociação, serão usados os dados em spool em vez de um novo exame da entrada. **Table Spool** é um operador físico.| 
|![Ícone do operador Spool de tabela](../relational-databases/media/table-spool-32x.gif "Ícone do operador Spool de tabela")|**Window Spool**|O operador **Window Spool** expande cada linha no conjunto de linhas que representa a janela associada a ele. Em uma consulta, a cláusula OVER define a janela em um conjunto de resultados de consulta e uma função de janela, e depois computa um valor para cada linha na janela. **Window Spool** é um operador lógico e físico.| 
|![Ícone do operador Atualização de tabela](../relational-databases/media/table-update-32x.gif "Ícone do operador Atualização de tabela")|**Table Update**|O operador físico **Table Update** atualiza linhas de entrada na tabela especificada na coluna **Argument** do plano de execução de consulta. O predicado SET: () determina o valor de cada coluna atualizada. Esses valores podem ser consultados na cláusula SET ou em outro lugar dentro desse operador assim como em outro lugar dessa consulta.| 
|![Ícone do operador Função com valor de tabela](../relational-databases/media/table-valued-function-32x.gif "Ícone do operador Função com valor de tabela")|**Table-valued Function**|O operador **Table-valued Function** avalia uma função com valor de tabela ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) e armazena as linhas resultantes no banco de dados [tempdb](../relational-databases/databases/tempdb-database.md) . Quando os iteradores pai solicitam as linhas, **Table-valued Function** retorna as linhas de **tempdb**.<br /><br /> As consultas com chamadas às funções com valor de tabela geram planos de consulta com o iterador de **Table-valued Function** . **Table-valued Function** pode ser avaliada com valores de parâmetros diferentes:<br /><br /> -<br /> O**Leitor de XML da Função com valor de tabela** insere um BLOB XML como parâmetro e processa um conjunto de linhas representando os nós XML na ordem dos documentos XML. Outros parâmetros de entrada podem restringir os nós XML retornados a um subconjunto de documentos XML.<br /><br /> -**Leitor de XML da Função com valor de tabela com filtro XPath** é um tipo especial de **Função com valor de tabela do Leitor de XML** que restringe a saída a nós XML que atendem a uma expressão XPath.<br /><br /> **Table-valued Function** é um operador lógico e físico.| 
|None|**Top N Sort**|**Top N Sort** é semelhante ao iterador **Classificar** , com exceção de que somente as primeiras *N* linhas são necessárias e não todo o conjunto de resultados. Para valores pequenos de *N*, o mecanismo de execução de consultas do [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] tenta executar toda a operação de classificação na memória. Para valores grandes de *N*, o mecanismo de execução de consultas recorre a um método de classificação mais genérico para o qual *N* não é um parâmetro.| 
|![Ícone do operador Superior](../relational-databases/media/top-32x.gif "Ícone do operador Superior")|**Top**|O operador **Top** verifica a entrada, retornando só o primeiro número ou porcentagem de linhas especificado, possivelmente com base em uma ordem de classificação. A coluna **Argument** pode conter uma lista das colunas cujas associações estão sendo verificadas. Em planos de atualização, o operador **Top** é usado para aplicar os limites de contagem de linhas. **Top** é um operador lógico e físico.| 
|![Ícone do operador estendido (UDX)](../relational-databases/media/udx-32x.gif "Ícone do operador estendido (UDX)")|**UDX**|Operadores estendidos (UDX) implementam uma de muitas operações XQuery e XPATH no [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Todos os operadores UDX são classificados como operadores lógicos e físicos.<br /><br /> O operador estendido (UDX) **FOR XML** é usado para serializar o conjunto relacional de linhas e insere em representação XML em uma única coluna BLOB, e em uma única linha de saída. É um operador de agregação XML sensível à ordenação.<br /><br /> O operador estendido (UDX) **XML SERIALIZER** é um operador de agregação XML sensível à ordenação. Ele insere linhas que representam nós XML ou escalares de XQuery em ordem de documento XML e produz um XML BLOB serializado em uma única coluna XML em uma única linha de saída.<br /><br /> O operador estendido (UDX) **XML FRAGMENT SERIALIZER** é um tipo especial de **XML SERIALIZER** que é usado para processar linhas de entrada que representam fragmentos de XML que são inseridos na extensão de modificação de dados de inserção de XQuery.<br /><br /> O operador estendido (UDX) **XQUERY STRING** avalia o valor da cadeia de caracteres XQuery das linhas de entrada que representam nós de XML. É um operador de agregação de cadeia sensível à ordenação. Produz uma linha com colunas que representam o escalar de XQuery que contém o valor de cadeia de caracteres da entrada.<br /><br /> O operador estendido (UDX) **XQUERY LIST DECOMPOSER** é um operador de decomposição de lista do XQuery. Para cada linha de entrada que representa um nó de XML ele produz uma ou mais linhas, cada uma representando o escalar de Xquery, que contém um valor de elemento de lista caso a entrada seja do tipo lista de XSD.<br /><br /> O operador estendido (UDX) **XQUERY DATA** avalia a função XQuery fn:data() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:data()** .<br /><br /> O operador estendido **XQUERY CONTAINS** avalia a função XQuery fn:contains() na entrada que representa os nós XML. É um operador de agregação de cadeia sensível à ordenação. Ele produz uma linha com colunas que representam o escalar de XQuery que contém o resultado de **fn:contains()** .<br /><br /> O operador estendido **UPDATE XML NODE** atualiza o nó XML na extensão de modificação de dados de substituição XQuery no método **modify()** no tipo XML.| 
|None|**Union**|O operador **Union** verifica várias entradas, gerando a saída de cada linha examinada e removendo duplicatas. **Union** é um operador lógico.| 
|![Ícone do operador Atualizar (Mecanismo de Banco de Dados)](../relational-databases/media/update-32x.gif "Ícone do operador Atualizar (Mecanismo de Banco de Dados)")|**Update (atualizar)**|O operador **Update** atualiza cada linha de sua entrada no objeto especificado na coluna **Argument** do plano de execução de consulta. **Update** é um operador lógico. O operador físico é **Table Update**, **Index Update**ou **Clustered Index Update**.| 
|![Ícone do elemento de linguagem While](../relational-databases/media/while-32x.gif "Ícone do elemento de linguagem While")|**While**|O operador **While** implementa [!INCLUDE[tsql](../includes/tsql-md.md)] durante o loop. **While** é um elemento de linguagem| 
  
